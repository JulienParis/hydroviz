
<style>

  /* MAP CSS */
  #content {
    padding-left: 0px;
    padding-right: 0px;
  }
  html,body,#map{
    height:100%;
    width: 100%;
    z-index: 1;
  }

  div .leaflet-control-container .leaflet-top {
    top: 20px;
  }


  div .leaflet-control-zoom {
    display: inline-flex;

  }
  div .leaflet-bar a:first-child {
    border-top-right-radius: 0px;
    border-top-left-radius: 4px;
    border-bottom-right-radius: 0px;
    border-bottom-left-radius: 4px;
    border-bottom : none;
    border-right : 1px solid #ccc ;
  }
  div .leaflet-bar a:last-child {
    border-top-right-radius: 4px;
    border-top-left-radius: 0px;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 0px;
  }

</style>


<div id="map" style="position: fixed;"></div>

<!-- CHROMA JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/chroma-js/0.5.9/chroma.min.js"></script>

<!-- MARKER CLUSTER -->
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.Default.css" />
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.css" />
<script type='text/javascript' src='https://unpkg.com/leaflet.markercluster@1.0.0/dist/leaflet.markercluster.js'></script>


<script>

  // CREATE EMPTY LAYERS GROUPS
  var water_layer    = new L.layerGroup();
  var admin_layer    = new L.layerGroup();

  //var stations_layer = new L.layerGroup();
  var stations_layer_cluster = L.markerClusterGroup({
      spiderfyOnMaxZoom: false,
      showCoverageOnHover: false,
      zoomToBoundsOnClick: true
  });

  // BASEMAP TILES
  var mbAttr =
    'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
    '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
    'Imagery <a href="http://mapbox.com">Mapbox</a>';
  var mbUrl  = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw';

  var grayscale  = L.tileLayer(mbUrl, {id: 'mapbox.light'  , attribution: mbAttr});
  var streets    = L.tileLayer(mbUrl, {id: 'mapbox.streets', attribution: mbAttr});

  // LEAFLET MAP OBJECT
  var map = L.map('map', {
    center: [47, 3],
    zoom: 6,
    layers: [ grayscale, water_layer ], // active layers
    zoomControl:false
  });

  // CREATE CONTROLS
  var baseLayers = {
    "Grayscale": grayscale,
    "Streets"  : streets
  };

  var overlays = {
    "water layer"    : water_layer,
    "admin layer"    : admin_layer,
    "stations layer" : stations_layer_cluster
  };

  var zoom = L.control.zoom( { position : "topright"} ).addTo(map);
  var controls = L.control.layers(baseLayers, overlays, { position:"topright" } ).addTo(map);

  // TOPOJSON HANDLING - TOPOJSON OBJECTS FOR LEAFLET
  L.TopoJSON = L.GeoJSON.extend({
    addData: function(jsonData) {
      if (jsonData.type === "Topology") {
        for (key in jsonData.objects) {
          geojson = topojson.feature(jsonData, jsonData.objects[key]);
          L.GeoJSON.prototype.addData.call(this, geojson);
        }
      }
      else {
        L.GeoJSON.prototype.addData.call(this, jsonData);
      }
    }
  }); // Copyright (c) 2013 Ryan Clark

  // CREATE EMPTY TOPOJSON-LEAFLET OBJECTS
  var topoLayer_water    = new L.TopoJSON();
  var topoLayer_admin    = new L.TopoJSON();
  var topoLayer_stations = new L.TopoJSON();

  // CREATE GRADIENTS --> CHECK VARIATIONS FROM COLORBREWER
  var colorScale_water = chroma
    .scale( {{ choropleths.seq_turquoise|safe }} )
    .domain([0, 0.3]);
  var colorScale_admin = chroma
      .scale( {{ choropleths.seq_turquoise|safe }} )
      .domain([0, 0.5]);

  var dft_opacity    = 0.5;
  var dft_weight     = 0.5;
  var dft_null_color = "#f0f0f0";

  // VIZUALISATION OF DATA
  function handleLayer(layer, value, layerGroup ){

    if (value != null ){

      fillOpacity = dft_opacity ;

      if (layerGroup == "water") {
        var fillColor = colorScale_water(value).hex();
      } else {
        var fillColor = colorScale_admin(value).hex();
      }
    }

    else {
      var fillColor   = dft_null_color ;
      var fillOpacity = 0 ;
    }

    layer.setStyle({
      fillColor  : fillColor,
      fillOpacity: fillOpacity,
      color      :'white',
      weight     :dft_weight,
      opacity    : 1
    });

    layer.on({
      mouseover: enterLayer,
      mouseout : leaveLayer,
      click    : zoomToFeature
    });
  }

  function enterLayer(){

    this.bringToFront();
    this.setStyle({
      weight : dft_weight + 2,
      opacity: 1
    });
  }

  function leaveLayer(){
    this.bringToBack();
    this.setStyle({
      weight : dft_weight,
      opacity: dft_opacity
    });
  }

  function zoomToFeature(e) {
    console.log(e);
    map.fitBounds(e.target.getBounds());
  }




  // update layer data
  function refreshTopoLayer ( layer_name, req_query, data_json ) {

    /// for instance : layer_name == "water"
    if (layer_name == df_ME){
      topoLayer = topoLayer_water;
    } else {
      topoLayer = topoLayer_admin;
    }

    topoLayer.eachLayer(

      function(layer) {

        if (layer_name == df_ME) {
          var index_geom = layer.feature.properties.CdMasseDEa ;
          //console.log(" io_slice_from_server / index_ME : ", index_ME)
        } else {
          var index_geom = layer.feature.properties.code ;
        }
        var data_geom = data_json[index_geom] ;
        //console.log(" io_slice_from_server / index_ME : " + index_ME + " / data_ME : ", data_ME) ;

        layer.feature.properties.value = data_geom ;

        if (data_geom != null ){
          if (data_geom[ req_query ] != null ) {
            value = data_geom[ req_query ]
          }
        } else {
          value = null
        }
        handleLayer(layer, value , layer_name);
      }
    );
  };


  // var queue = d3_queue.queue(1);
  // queue
  //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.water ) }}" ) // topojson water
  //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.admin ) }}" ) // topojson admin
  //   .awaitAll(InitMap_) ;



  //// InitMap as callback function --> first to run then (callback)

  function InitMap (callback) {
  //function InitMap () {
  //InitMap = function (callback) {

    //var def = new $.Deferred();

    // GET TOPOJSON FILES
    $.getJSON( "{{ url_for ( 'static', filename = basemaps.water ) }}" )
      .done(addTopoData_water);
    $.getJSON( "{{ url_for( 'static', filename = basemaps.admin ) }}" )
       .done(addTopoData_admin);

    // PROCESS TOPOJSON // WARNING : OVERWRITES previous TOPOLAYER object
    function addTopoData_water(topoData){
      console.log(" - leaflet -- starting / addTopoData_water ");
      topoLayer_water.addData(topoData);
      topoLayer_water.addTo(water_layer);
      //topoLayer_water.eachLayer(handleWaterLayer); //////////////////
      console.log(" - leaflet -- finished / addTopoData_water ");

      callback(); // <-- callback inside last called function
    };

    function addTopoData_admin(topoData){
      console.log(" - leaflet -- starting / addTopoData_admin ");
      topoLayer_admin.addData(topoData);
      topoLayer_admin.addTo(admin_layer);
      //topoLayer_admin.eachLayer(handleAdminLayer); /////////////////
      console.log(" - leaflet -- finished / addTopoData_admin ");
    };

    //return def.promise();

  }; // <-- end : InitMap


  var df_ME  = "df_AV_ME"  ;
  var df_dpt = "df_AV_dpt" ;

  //ConnectSocketIO = function () {
  function ConnectSocketIO () {

    var req_client = "request IO from client";
    var year   = "2011"   ;
    var pest   = "XXXXXX" ;

    // INITIATE SOCKET IO CONNECTION
    var socket = io.connect('http://' + document.domain + ':' + location.port);

    function EmitRequestSlice(df_name) {
      socket.emit(
        'io_request_water', {
          msg                 : req_client ,
          df_source           : df_name ,
          slice_query_index   : [ year, pest ] ,
          slice_query_columns : [ ]
        }
      );
    };

    socket.on('connect', function() {
      // socket.emit('connection start', {data: '--> client connected from : ' + document.domain + ':' + location.port });
      EmitRequestSlice(df_ME);
      //EmitRequestSlice(df_dpt);
    });

    socket.on('io_slice_from_server', function(data_slice) {

      var req_query  = data_slice.request_query ; // "2007_XXXXXX" for instance
      var req        = data_slice.request_sent  ;
      var data_      = data_slice.slice_df    ;
      var req_df     = req.df_source  ;

      console.log(" io_slice_from_server / req : ", req) ;
      console.log(" io_slice_from_server / req_df : ", req_df) ;

      var data_json = JSON.parse(data_) ;

      refreshTopoLayer ( req_df, req_query, data_json );

      // update layer data
      // topoLayer_water.eachLayer(
      //
      //   function(layer) { ///////////////////////////////////////////////////
      //
      //     var index_ME = layer.feature.properties.CdMasseDEa ;
      //     //console.log(" io_slice_from_server / index_ME : ", index_ME)
      //
      //     var data_ME = data_json[index_ME] ;
      //     //console.log(" io_slice_from_server / index_ME : " + index_ME + " / data_ME : ", data_ME) ;
      //
      //     layer.feature.properties.value = data_ME ;
      //
      //     if (data_ME != null ){
      //       if (data_ME[ req_query ] != null ) {
      //         value = data_ME[ req_query ]
      //       }
      //     } else {
      //       value = null
      //     }
      //     handleLayer(layer, value , "water");
      //   }
      // );

    }); // <-- end : io_slice_from_server

    $('.request').on('click', function() {

      var req_value = $(this).attr("reqvalue");
      var req_type  = $(this).attr("reqtype");

      console.log( "req_type : " + req_type + " / " + req_value + " (" + jQuery.type(req_value) + ")" );
      if ( req_type == "year") {
        year = req_value ;
      }

      EmitRequestSlice(df_ME)

    });

  }; // <-- end : ConnectSocketIO


  $(document).ready(function() { // <-- place at top to run stuff in order

    //InitMap().then(ConnectSocketIO); // <-- with defer
    InitMap( ConnectSocketIO ); // <-- with callback
    //ConnectSocketIO();

  }); //<-- end : $(document).ready


</script>
