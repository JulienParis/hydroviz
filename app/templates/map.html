
<style>

  /* MAP CSS */
  #content {
    padding-left: 0px;
    padding-right: 0px;
  }
  html,body,#map{
    /*height : 90%;*/
    width  : 100%;
    z-index: 1;
  }

  div .leaflet-control-container .leaflet-top {
    top: 20px;
  }


  div .leaflet-control-zoom {
    display: inline-flex;

  }
  div .leaflet-bar a:first-child {
    border-top-right-radius: 0px;
    border-top-left-radius: 4px;
    border-bottom-right-radius: 0px;
    border-bottom-left-radius: 4px;
    border-bottom : none;
    border-right : 1px solid #ccc ;
  }
  div .leaflet-bar a:last-child {
    border-top-right-radius: 4px;
    border-top-left-radius: 0px;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 0px;
  }


  .info {
      padding: 6px 8px;
      font: 14px/16px Arial, Helvetica, sans-serif;
      background: white;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 5px;
  }
  .info h4 {
      margin: 0 0 5px;
      color: #777;
  }

  .legend span, .legend label {
  display: block;
  width: 40px;
  height: 15px;
  float: left;
  /*opacity: 0.7;*/
  text-align: center;
  font-size: 80%
  }

</style>


<div id="map" style="position: fixed;"></div>

<!-- CHROMA JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/chroma-js/0.5.9/chroma.min.js"></script>

<!-- MARKER CLUSTER -->
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.Default.css" />
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.css" />
<script type='text/javascript' src='https://unpkg.com/leaflet.markercluster@1.0.0/dist/leaflet.markercluster.js'></script>


<script>

  // CHECK WINDOW SIZE
  $(window).load(function() {

    var window_w = window.innerWidth;
    var window_h = window.innerHeight;
    var navbar_h = $('header').outerHeight();
    var map_h    = window_h - navbar_h ;
    console.log( "window_w : ", window_w," - window_h : ", window_h, " - navbar_h : ", navbar_h );
    // return desired height to map
    $('#map').css({"height": map_h});

    // CREATE EMPTY LAYERS GROUPS
    var ME_layer     = new L.layerGroup();
    var rivers_layer = new L.layerGroup();
    var admin_layer  = new L.layerGroup();

    //var stations_layer = new L.layerGroup();
    var stations_layer_cluster = L.markerClusterGroup({
        spiderfyOnMaxZoom: false,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });

    // BASEMAP TILES
    var mbAttr = 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
      '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
      'Imagery <a href="http://mapbox.com">Mapbox</a>';
    var mbUrl  = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw';

    var grayscale  = L.tileLayer(mbUrl, {id: 'mapbox.light'  , attribution: mbAttr});
    var streets    = L.tileLayer(mbUrl, {id: 'mapbox.streets', attribution: mbAttr});

    // LEAFLET MAP OBJECT
    var map = L.map('map', {
      center     : [47, 3],
      zoom       : 6,
      layers     : [ grayscale, ME_layer, rivers_layer ], // active layers
      zoomControl:false
    });

    // CREATE CONTROLS
    var baseLayers = {
      "Fond gris": grayscale,
      "Fond OSM" : streets
    };

    var overlays = {
      "nappes phréatiques" : ME_layer,
      "départements"       : admin_layer,
      "stations de mesure" : stations_layer_cluster,
      "eaux de surface"    : rivers_layer,
    };

    var zoom     = L.control.zoom( { position : "topright"} ).addTo(map);
    var controls = L.control.layers(
      baseLayers, overlays,
      { position : "topright" }
    ).addTo(map);


    // TOPOJSON HANDLING - TOPOJSON OBJECTS FOR LEAFLET
    L.TopoJSON = L.GeoJSON.extend({
      addData: function(jsonData) {
        if (jsonData.type === "Topology") {
          for (key in jsonData.objects) {
            geojson = topojson.feature(jsonData, jsonData.objects[key]);
            L.GeoJSON.prototype.addData.call(this, geojson);
          }
        }
        else {
          L.GeoJSON.prototype.addData.call(this, jsonData);
        }
      }
    }); // Copyright (c) 2013 Ryan Clark

    // CREATE EMPTY TOPOJSON-LEAFLET OBJECTS
    var topoLayer_water    = new L.TopoJSON();
    var topoLayer_rivers   = new L.TopoJSON();
    var topoLayer_admin    = new L.TopoJSON();
    var topoLayer_stations = new L.TopoJSON();

    // VARIABLES DATA / DATA REQUESTS
    var df_ME       = "df_AV_ME"    ;
    var df_dpt      = "df_AV_dpt"   ;
    var df_stations = "df_stations" ;
    var df_rivers   = "df_rivers"   ;


    // CREATE GRADIENTS --> CHECK VARIATIONS FROM COLORBREWER
    var scale_limitMid         = {{ colorscaleLimits.limit_middle }} ;
    var scale_limitUp          = {{ colorscaleLimits.limit_up }} ;
    var scale_limitMinus       = {{ colorscaleLimits.limit_minus }} ;

    var scale_limitUp_count    = 100 ;


    var min_value_count        = 0   ;
    var max_value_count        = 100 ;
    var min_max_array_count    = [0, 5, 10, 15, 20, 25, 40, 50, 70, 85, 100 ] ;

    var min_value_concent      = 0.0 ;
    var max_value_concent      = 5.0 ;
    var min_max_array_concent  = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5] ;

    var min_value_diverg        = -3.0 ;
    var max_value_diverg        = 3.0 ;
    var min_max_array_diverg    = [-3.0, -1.0, -0.3, -0.2, -0.1, 0.0, 0.1, 0.2, 0.3, 1.0, 3.0] ;




    // var min_value_ME      = 0.0 ; /////////////////////////////////////////////////
    // var max_value_ME      = 5.0 ; /////////////////////////////////////////////////
    // var min_max_array_ME  = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5]  ; /////////////////////////////////////////////////
    //
    // var min_value_dpt     = 0.0 ; /////////////////////////////////////////////////
    // var max_value_dpt     = 5.0 ; /////////////////////////////////////////////////
    // var min_max_array_dpt = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5]  ; /////////////////////////////////////////////////


    var dft_opacity       = 0.4;
    var dft_weight        = 0.5;
    var dft_rivers_weight = 0.2;
    var dft_null_color    = "#f0f0f0" ;
    var dft_stroke_color  = "white"   ;
    var dft_rivers_color  = "#081d58" ;

    // default request values for init
    var req_client = "request IO from client";
    var year       = "2007"   ;
    var pest_map   = "XXXXXX" ;
    var categ_map  = "sequential" ;
    var index_map  = "MOYPTOT";
    var index_geom = "TOT_FRANCE" ;


    // choose between  - sequential / divergent / qualitative - colorscales
    function chooseColorScale( seq_div_qual ) {

      if ( seq_div_qual == "sequential" ) {
        var colorScale  = chroma
          .scale( {{ choropleths.seq_beige_blue_red|safe }} )
          .domain( [ 0.0001, scale_limitUp ], 9, 'log' );
      }
      else if ( seq_div_qual == "counts") {
        var colorScale  = chroma
          .scale( {{ choropleths.seq_yel_red|safe }} )
          .domain( [ 0.0, scale_limitUp_count ], 9 );
      }
      else if ( seq_div_qual == "divergent") {
        var colorScale  = chroma
          .scale( {{ choropleths.div_gre_yel_red|safe }} )
          .domain( [ -3.0, 3.0 ], 11 );
      }
      else if (seq_div_qual == "qualitative") {
        var colorScale  = chroma
          .scale( {{ choropleths.qual_12_hard|safe }} )
          .domain( [ 0, 12 ] );
      }
      ;

      return colorScale ;
    };

    function chooseMinMaxArray( seq_div_qual ) {
      if ( seq_div_qual == "sequential" ){
        var min_max_array = min_max_array_concent ;
      }
      else if ( seq_div_qual == "counts" ){
        var min_max_array = min_max_array_count ;
      }
      else if ( seq_div_qual == "divergent" ){
        var min_max_array = min_max_array_diverg ;
      }
      else if ( seq_div_qual == "qualitative" ){
        var min_max_array = min_max_array_count ;
      };

      return min_max_array;
    };

    // function chooseMinMaxArray( req_df ) {
    //   if ( selected_layer == df_ME ){
    //     var min_max_array = min_max_array_ME ;
    //   }
    //   else if ( selected_layer == df_dpt ){
    //     var min_max_array = min_max_array_dpt ;
    //   };
    //   return min_max_array;
    // };

    // CREATE LEGEND
    var legend ; // global empty variable
    var selected_layer = df_ME ;
    //var scale_categ    = "sequential" ;
    //var categ          = "MOYPTOT"    ;


    // create legend control
    function createLegend( seq_div_qual ) {

      var colorScale    = chooseColorScale(  seq_div_qual );
      var min_max_array = chooseMinMaxArray( seq_div_qual );
      // var min_max_array = chooseMinMaxArray( selected_layer );

      console.log("createLegend / selected_layer :", selected_layer );

      legend = L.control({position: 'bottomright'});

      legend.onAdd = function (map) {

          var div = L.DomUtil.create('div', 'info legend');
          var grades = min_max_array  ;

          if (seq_div_qual == "sequential")  { var label = "moyenne des concentrations totales " + "(" + year + ")", unit = "ug/l" ; }
          else if (seq_div_qual == "counts") { var label = "nombre de pesticides / " + index_map + " : " + pest_map + " (" + year + ")",    unit = "pest." ; };

          div.innerHTML += '<p>' + label + '</p>';

          // loop through our density intervals and generate a label with a colored square for each interval
          // first loop for colored legend boxes
          for (var i = 0; i < grades.length; i++) {
              div.innerHTML +=
                  '<span style="background:' + colorScale(grades[i]) + '; opacity:' + dft_opacity + '"></span> ';
          }
          // a line break
          div.innerHTML += '<br>';

          // second loop for text
          for (var i = 0; i < grades.length; i++) {
              div.innerHTML +=
                  '<label>' + (grades[i + 1] ? '<' + grades[i]  : '>=' + grades[i] ) + '</label>';
          }
          div.innerHTML += '<label>' + unit + '</label>';

          return div;
      };

      legend.addTo(map);

    };


    // VIZUALISATION OF DATA ON LAYERS
    function handleLayer(layer, value_fill, req_df, seq_div_qual ){

      var stroke_color  = dft_stroke_color ;
      var stroke_weight = dft_weight ;

      // ignore null values when coloring
      if (value_fill != null ){

        //fillOpacity = ( dft_opacity * value_fill / max_value ) + 0.1 ;
        fillOpacity = dft_opacity  ;

        var colorScale = chooseColorScale( seq_div_qual );
        var fillColor  = colorScale(value_fill).hex();

        // if ( layer_name == df_ME ) {
        //   var fillColor = colorScale_ME(value_fill).hex();
        // } else if (layer_name == df_dpt ) {
        //   var fillColor = colorScale_dpt(value_fill).hex();
        // }
      }

      else { /// <-- rivers for now
        var fillColor   = dft_null_color ;
        var fillOpacity = 0 ;
        stroke_color    = dft_rivers_color  ;
        stroke_weight   = dft_rivers_weight ;
      }

      //layer.bindpopup()
      layer.setStyle({
        fillColor  : fillColor,
        fillOpacity: fillOpacity,
        color      : stroke_color,
        weight     : stroke_weight,
        opacity    : 1
      });

      if (req_df != df_rivers ) {
        layer.on({
          mouseover: enterLayer,
          mouseout : leaveLayer,
          click    : zoomToFeature
        });
      };
    };

    function enterLayer(){
      //this.bringToFront();
      this.setStyle({
        weight : dft_weight + 3,
        opacity: 1
      });
    };

    function leaveLayer(){
      //this.bringToBack();
      this.setStyle({
        weight : dft_weight,
        opacity: dft_opacity
      });
      // rivers_layer.eachLayer( function(layer) {
      //   layer.bringToBack()
      //});
    };

    function zoomToFeature(e) {

      //map.fitBounds(e.target.getBounds());

      var props = e.target.feature.properties ;
      //console.log(props);
      //toggleSidebarInfos();
      displayInfos(props);
    };

    // display infos on click
    var toggledLast ;
    function displayInfos(props) {

      //var props = e.target.feature.properties;
      // if ( ) { }
      // else if () {};

      // close sidebar
      if (toggledLast == props | toggled == -1 ) {
        toggleSidebarInfos();
      }

      // do nothing
      else {
        //if (node.type != "comment") {
        toggledLast = props ;
        console.log(props);

        d3.select('#sb_title').html(props.NomMasseDE);

        d3.select('#CdMasseDEa').html(props.CdMasseDEa);
        // d3.select('#NomMasseDE').html(props.NomMasseDE);
        d3.select('#Karstique').html(props.Karstique);
        d3.select('#FrangeLitt').html(props.FrangeLitt);
        d3.select('#Niveau').html(props.Niveau);
        d3.select('#NatureEcou').html(props.NatureEcou);

        d3.select('#FONCTIONS').html(props.FUNCTIONS);

        //}
      }

    };

    // refresh min-max values
    // function refreshMinMax_MOYPTOT ( req_df_, data_minmax ) {
    //
    //   new_min    = data_minmax.min ;
    //   new_max    = data_minmax.max ;
    //   new_minmax = data_minmax.min_max_array ;
    //
    //   // update min_max arrays
    //   if ( req_df_ == df_ME ){
    //     min_max_array_ME = new_minmax ;
    //     max_value_ME     = new_max ;
    //     min_value_ME     = new_min ;
    //   }
    //   else if ( req_df_ == df_dpt ){
    //     min_max_array_dpt = new_minmax ;
    //     max_value_dpt     = new_max ;
    //     min_value_dpt     = new_min ;
    //   } ;
    //
    //   console.log("refreshMinMax_MOYPTOT / new_minmax :", new_minmax );
    //
    // };



    // refresh legend scale
    function refreshLegend ( req_df_, seq_div_qual ) {

      console.log("refreshLegend " );
      //console.log("refreshLegend / legend :", legend );

      // new_min    = data_minmax.min ;
      // new_max    = data_minmax.max ;
      // new_minmax = data_minmax.min_max_array ;
      //
      // // update min_max arrays
      // if ( req_df_ == df_ME ){
      //   min_max_array_ME = new_minmax ;
      //   max_value_ME     = new_max ;
      //   min_value_ME     = new_min ;
      // }
      // else if ( req_df_ == df_dpt ){
      //   min_max_array_dpt = new_minmax ;
      //   max_value_dpt     = new_max ;
      //   min_value_dpt     = new_min ;
      // } ;
      //
      // console.log("refreshLegend / new_minmax :", new_minmax );

      // refresh legend only if it corresponds to selected layer
      if ( req_df_ == selected_layer ){

        // remove previous legend if already exists
        if (legend != undefined) {
          legend.remove();
          //console.log("refreshLegend / legend.remove() ");
        };

        // recreate a legend choosing between sequential / divergent / qualitative
        createLegend( seq_div_qual ) ;

      };
    };

    // update layer data
    function refreshTopoLayer ( req_df, dataset ) {

      if ( req_df == df_ME ){
        topoLayer = topoLayer_water;
      } else if ( req_df == df_dpt ) {
        topoLayer = topoLayer_admin;
      } else {
        topoLayer = topoLayer_rivers;
      };

      console.log("refreshTopoLayer / start for req_df :", req_df );

      topoLayer.eachLayer(

        function(layer) {

          if (req_df == df_ME) {
            var index_geom = layer.feature.properties.CdMasseDEa ;
            //console.log(" io_slice_from_server / index_ME : ", index_ME)
          } else if (req_df == df_dpt) {
            var index_geom = layer.feature.properties.code ;
          } else {
            var index_geom = null ;
          };

          var data_L_MOYPTOT         = dataset["MOYPTOT"][ index_geom ] ;
          //var data_L_MOYPTOT_all_CAS = _.pickBy(dataset["MOYPTOT_all_CAS"][ index_geom ]) ; // using LoDash to skip null values
          //var data_L_MOYPTOT_all_CAS = _.omitBy(dataset["MOYPTOT_all_CAS"][ index_geom ], _.isNil ) ; // using LoDash to skip null values
          var data_L_FUNCTIONS       = dataset["FUNCTIONS"][ index_geom ] ;
          var data_L_FAMILLES        = dataset["FAMILLES"][ index_geom ] ;
          var data_L_TYPES           = dataset["TYPES"][ index_geom ] ;

          layer.feature.properties.MOYPTOT         = data_L_MOYPTOT ;
          //layer.feature.properties.MOYPTOT_all_CAS = data_L_MOYPTOT_all_CAS ;
          layer.feature.properties.FUNCTIONS       = data_L_FUNCTIONS ;
          layer.feature.properties.FAMILLES        = data_L_FAMILLES ;
          layer.feature.properties.TYPES           = data_L_TYPES ;

        }
      );
    };

    // refresh map : colors and scale
    function refreshMap ( req_df, index_map, req_query, seq_div_qual ) {

      console.log("refreshMap / start for req_df :", req_df );

      if      ( req_df == df_ME  ) { topoLayer = topoLayer_water; }
      else if ( req_df == df_dpt ) { topoLayer = topoLayer_admin; }
      else                         { topoLayer = topoLayer_rivers; };

      topoLayer.eachLayer(

        function(layer) {

          if      (index_map == "MOYPTOT")         { value_ = layer.feature.properties.MOYPTOT   }
          //if      (index_map == "MOYPTOT_all_CAS") { value_ = layer.feature.properties.MOYPTOT_all_CAS  }
          else if (index_map == "FUNCTIONS")       { value_ = layer.feature.properties.FUNCTIONS }
          else if (index_map == "FAMILLES")        { value_ = layer.feature.properties.FAMILLES  }
          else if (index_map == "TYPES")           { value_ = layer.feature.properties.TYPES     } ;

          // handle missing data
          //console.log( layer.feature.properties.CdMasseDEa , value_);

          if (value_ != null ){
            if ( req_query in value_ ) {
              value_fill = value_[ req_query ]
            }
            else {
              value_fill = null
            }
          } else {
            value_fill = null
          };

          //console.log( value_[ req_query ]);
          //console.log( value_fill );

          //console.log("refreshMap / value_fill :", value_fill );

          handleLayer( layer, value_fill , req_df, seq_div_qual );

        });

    };

    // var queue = d3_queue.queue(1);
    // queue
    //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.water ) }}" ) // topojson water
    //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.admin ) }}" ) // topojson admin
    //   .awaitAll(InitMap_) ;

    //// InitMap as callback function --> first to run then (callback)

    //function InitMap () {
    //InitMap = function (callback) {
    function InitMap (callback) {

      //var def = new $.Deferred();

      // GET TOPOJSON FILES
      $.getJSON( "{{ url_for ( 'static', filename = basemaps.ME ) }}" )
        .done(addTopoData_ME);
      $.getJSON( "{{ url_for( 'static', filename  = basemaps.admin ) }}" )
         .done(addTopoData_admin);
      $.getJSON( "{{ url_for( 'static', filename  = basemaps.rivers ) }}" )
        .done(addTopoData_rivers);


      // PROCESS TOPOJSON // WARNING : OVERWRITES previous TOPOLAYER object
      function addTopoData_ME(topoData){
        console.log(" - leaflet -- starting / addTopoData_ME ");
        topoLayer_water.addData(topoData);
        topoLayer_water.addTo(ME_layer);
        console.log(" - leaflet -- finished / addTopoData_ME ");

        callback(); // <-- callback inside last called function
      };

      function addTopoData_admin(topoData){
        console.log(" - leaflet -- starting / addTopoData_admin ");
        topoLayer_admin.addData(topoData);
        topoLayer_admin.addTo(admin_layer);
        console.log(" - leaflet -- finished / addTopoData_admin ");
      };

      function addTopoData_rivers(topoData){
        console.log(" - leaflet -- starting / addTopoData_rivers ");
        topoLayer_rivers.addData(topoData);
        topoLayer_rivers.addTo(rivers_layer);

        //topoLayer_rivers.eachLayer(handleLayer); /////////////////////////////////////
        topoLayer_rivers.eachLayer(
          function (layer) {
            handleLayer(layer, null , df_rivers);
            layer.bringToBack();
          }
        );

        console.log(" - leaflet -- finished / addTopoData_rivers ");
        console.log("");

      };

      // modify Leaflet controls
      $(".leaflet-control-layers").addClass("leaflet-control-layers-expanded") ;

      //return def.promise();

    }; // <-- end : InitMap


    // START ConnectSocketIO = function () {
    function ConnectSocketIO () {

      // // default request values ^^^ moved upper in code
      // var req_client = "request IO from client";
      // var year       = "2007"   ;
      // var pest_map   = "XXXXXX" ;
      // var categ_map  = "sequential" ;
      // var index_map  = "MOYPTOT";

      // INITIATE SOCKET IO CONNECTION
      var socket = io.connect('http://' + document.domain + ':' + location.port);

      // EMIT REQUEST SLICE TO SERVER
      function EmitRequestSlice(df_name) {
        socket.emit(
          'io_request_slice', {
            msg                 : req_client ,
            df_source           : df_name ,
            slice_query_index   : [ year, pest_map ] ,
            slice_query_columns : [ ]
          }
        );
      };

      // EMIT REQUEST TREE TO SERVER
      function EmitRequestTree(df_name, area ) {
        socket.emit(
          'io_request_tree', {
            msg                 : req_client ,
            df_source           : df_name ,
            slice_query_index   : [ year, pest_map ] ,
            slice_query_columns : area
          }
        );
      };

      // INITIATE MAP DATAS ON CONNECTION
      socket.on('connect', function() {
        // socket.emit('connection start', {data: '--> client connected from : ' + document.domain + ':' + location.port });

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        EmitRequestTree(df_ME, index_geom );

      });

      // IO - REFRESH DATAS AND MAP WHEN RECEIVING NEW DATA
      socket.on('io_slice_from_server', function( data_slice ) {

        //var req_query            = pest ; //data_slice.request_query   ; // "XXXXXX" for instance

        console.log(" *** io_slice_from_server / data_slice (raw) : "  , data_slice ) //, " - req_query : ", req_query ) ;

        var data_MOYPTOT         = data_slice.slice_MOYPTOT.data    ;
        //var data_MOYPTOT_minmax  = data_slice.slice_MOYPTOT.min_max ;

        //var data_MOYPTOT_all_CAS = data_slice.slice_MOYPTOT_all_CAS.data    ;

        var data_FUNCTIONS       = data_slice.slice_FUNCTIONS.data ;
        var data_FAMILLES        = data_slice.slice_FAMILLES.data  ;
        var data_TYPES           = data_slice.slice_TYPES.data     ;

        //var seq_div_qual         = data_slice.seq_div_qual    ;
        var req                  = data_slice.request_sent    ;
        var req_df_              = req.df_source              ;

        //console.log(" io_slice_from_server / req : ", req) ;
        console.log(" *** io_slice_from_server / req_df_ : "    , req_df_ ) //, " - req_query : ", req_query ) ;
        //console.log(" io_slice_from_server / data_minmax : ", data_MOYPTOT_minmax) ;



        // parse data from JSON
        var data_MOYPTOT_json         = JSON.parse(data_MOYPTOT) ;
        //var data_MOYPTOT_all_CAS_json = JSON.parse(data_MOYPTOT_all_CAS) ;
        var data_FUNCTIONS_json       = JSON.parse(data_FUNCTIONS) ;
        var data_FAMILLES_json        = JSON.parse(data_FAMILLES) ;
        var data_TYPES_json           = JSON.parse(data_TYPES) ;

        var dataset = {
          "MOYPTOT"         : data_MOYPTOT_json,
          //"MOYPTOT_all_CAS" : data_MOYPTOT_all_CAS_json,
          "FUNCTIONS"       : data_FUNCTIONS_json,
          "FAMILLES"        : data_FAMILLES_json,
          "TYPES"           : data_TYPES_json
        };

        // set global vars for TOT_FRANCE for treemap
        //var MOYPTOT_FR   = data_MOYPTOT_json["TOT_FRANCE"] ;
        var FUNCTIONS_FR = data_FUNCTIONS_json["TOT_FRANCE"] ;
        var FAMILLES_FR  = data_FAMILLES_json["TOT_FRANCE"] ;
        var TYPES_FR     = data_TYPES_json["TOT_FRANCE"] ;


        // refresh in ordrer : MINMAX -> LEGEND -> TOPOLAYER --> MAP
        //refreshMinMax_MOYPTOT ( req_df_, data_MOYPTOT_minmax ) ;
        refreshLegend(          req_df_, categ_map ) ;
        refreshTopoLayer(       req_df_, dataset );
        // refreshMap (            req_df_, "MOYPTOT_all_CAS", req_query, seq_div_qual );
        refreshMap (            req_df_, index_map, pest_map, categ_map );

        console.log("");

      }); // <-- end : io_slice_from_server


      // IO - REFRESH DATAS AND TREEMAP WHEN RECEIVING NEW DATA
      socket.on('io_tree_from_server', function ( tree_pests ) {

        console.log( " *** io_tree_from_server", tree_pests );
        var tree_FAMILLES  = JSON.parse(tree_pests.tree_FAMILLES) ;
        var tree_FUNCTIONS = JSON.parse(tree_pests.tree_FUNCTIONS) ;
        var tree_TYPES     = JSON.parse(tree_pests.tree_TYPES) ;

        console.log( " *** io_tree_from_server / tree_FAMILLES" );
        console.log(tree_FAMILLES);

        starter(tree_FAMILLES);

        }

      ); // <-- end : io_tree_from_server




      // REQUEST BUTTONS
      $('.request').on('click', function() {

        var req_value = $(this).attr("reqvalue");
        var req_type  = $(this).attr("reqtype") ;

        //console.log( "req_type : " + req_type + " / " + req_value + " (" + jQuery.type(req_value) + ")" );

        if ( req_type == "year") {
          year = req_value ;
        }

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        EmitRequestTree(df_ME, index_geom );

      });


      // SLIDER YEARS
      $("#slider_years").on("input change", function() {

        console.log(this) ;

        var year_slide = this.value ;

        console.log(year_slide) ;

        document.querySelector('#annee_selected').value = year_slide ;

        var req_value = year_slide ;
        var req_type  = "year";

        // console.log( "req_type : " + req_type + " / " + req_value + " (" + jQuery.type(req_value) + ")" );
        if ( req_type == "year") {
          year = req_value ;
        }

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        EmitRequestTree(df_ME, index_geom);

      });


      // BUTTONS FOR COUNTS : FUNCTIONS / FAMILLES / TYPES
      // TO DO ... /////////////////////////////////////////////////////////////////////////////
      $(".switchmap").on("click", function() {

        console.log(this) ;

        var req_value = $(this).attr("reqvalue"); // ex.
        var req_type  = $(this).attr("reqtype") ; // ex.

        if ( req_type == "MOYPTOT" ) { categ_map = "sequential" }
        else                         { categ_map = "counts" };

        var req_df_ = df_ME   ; /////////

        index_map = req_type  ;
        pest_map  = req_value ;

        console.log("req_value : ", req_value , " / req_type : ", req_type) ;

        refreshLegend( req_df_, categ_map ) ;
        refreshMap (   req_df_, index_map, pest_map, categ_map );

      });


    }; // <-- end : ConnectSocketIO


  $(document).ready(function() { // <-- place at top to run stuff in order

    //InitMap().then(ConnectSocketIO); // <-- with defer
    //ConnectSocketIO();
    InitMap( ConnectSocketIO ); // <-- with callback

    console.log(" - InitMap / finished ");
    console.log(" ");

  }); //<-- end : $(document).ready



}); // <-- end : $(window).load


</script>
