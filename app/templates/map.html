
<style>

  /* MAP CSS */
  #content {
    padding-left : 0px;
    padding-right: 0px;
  }
  html,body,#map{
    /*height : 90%;*/
    width  : 100%;
    z-index: 1;
  }

  div .leaflet-control-container .leaflet-top {
    top: 20px;
  }

  div .leaflet-top.leaflet-right{
    display: inline-flex;
  }

  div .leaflet-control-zoom {
    display: inline-flex;

  }
  div .leaflet-bar a:first-child {
    border-top-right-radius: 0px;
    border-top-left-radius : 4px;
    border-bottom-right-radius: 0px;
    border-bottom-left-radius : 4px;
    border-bottom : none;
    border-right  : 1px solid #ccc ;
  }
  div .leaflet-bar a:last-child {
    border-top-right-radius: 4px;
    border-top-left-radius : 0px;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius : 0px;
  }


  .info {
    padding: 6px 8px;
    font   : 14px/16px Arial, Helvetica, sans-serif;
    background: white;
    background: rgba(255,255,255,0.8);
    box-shadow: 0 0 15px rgba(0,0,0,0.2);
    border-radius: 5px;
  }
  .info h4 {
      margin: 0 0 5px;
      color : #777;
  }

  .legend span, .legend label {
    display: block;
    width: 40px;
    height: 15px;
    float: left;
    /*opacity: 0.7;*/
    text-align: center;
    font-size: 80%
  }

  .tooltip_map {
    position  : absolute;
    text-align: center;
    color  : white;
    width  : 100px;
    height : auto;
    padding: 2px;
    font   : 10px sans-serif;
    background: #7841a9 ;
    opacity: .8;
    border : 0px;
    border-radius : 3px;
    pointer-events: none;
    z-index : inherit;
  }

</style>


<div id="map" style="position: fixed;"></div>

<!-- CHROMA JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/chroma-js/0.5.9/chroma.min.js"></script>

<!-- MARKER CLUSTER -->
<!-- <link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.Default.css" />
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.css" />
<script type='text/javascript'         src='https://unpkg.com/leaflet.markercluster@1.0.0/dist/leaflet.markercluster.js'></script> -->

<!-- GROUPED LAYERS -->
<link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='css/leaflet.groupedlayercontrol.css') }}" />
<script type="text/javascript"         src="{{  url_for('static', filename='js/leaflet.groupedlayercontrol.js') }}"></script>

<!-- PRINT MAP  -->
<script type="text/javascript"         src="{{  url_for('static', filename='js/leaflet.easyPrint.js') }}"></script>



<script>


  var dict_categs_legend = {
    "FUNCTIONS" : { "H"   : "herbicides",
                    "I"   : "insecticides" ,
                    "F"   : "fongicides",
                    "I,A" : "insecticides, acaricides",
                    "Reg" : "régulateurs de croissance",
                    "I,N" : "insecticides, nématicides",
                    "F,N" : "fongicides, nématicides",
                    "Ro"  : "rodenticides",
                    "I,A,F,H" : "insecticides, acaricides, fongicides, herbicides",
                    "I,Reg" : "insecticides, régulateurs de croissance",
                    "I,A,M" : "insecticides, acaricides, mollusticides",
                    "RepO"  : "répulsif",
                    "no ref": "fonction non identifiée"
                    },
    "FAMILLES"  : {},
    "TYPES"     : { "Ia"    : "extrêment toxique",
                    "Ib"    : "très toxique",
                    "II"    : "modérément toxique",
                    "III"   : "légèrement toxique",
                    "no ref": "dangerosité non identifiée"
                    }
  };


  // CHECK WINDOW SIZE
  $(window).load(function() {


    var window_w = window.innerWidth;
    var window_h = window.innerHeight;
    var navbar_h = $('header').outerHeight();
    var map_h    = window_h - navbar_h ;
    console.log( "window_w : ", window_w," - window_h : ", window_h, " - navbar_h : ", navbar_h );
    // return desired height to map
    $('#map').css({"height": map_h});

    // CREATE EMPTY LAYERS GROUPS
    var ME_layer     = new L.layerGroup();
    var rivers_layer = new L.layerGroup();
    var admin_layer  = new L.layerGroup();
    // var cities_layer = new L.layerGroup();

    //var stations_layer = new L.layerGroup();
    // var stations_layer_cluster = L.markerClusterGroup({
    //     spiderfyOnMaxZoom: false,
    //     showCoverageOnHover: false,
    //     zoomToBoundsOnClick: true
    // });

    // BASEMAP TILES
    // check list free basemaps : http://leaflet-extras.github.io/leaflet-providers/preview/

    // MAPBOX BASEMAPS DEPRECATED
    var MAPBOX_Url  = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw';
    var MAPBOX_Attr = 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
      '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
      'Imagery <a href="http://mapbox.com">Mapbox</a>';

    var OSM_BW_Url  = 'http://{s}.tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png';
    var OSM_BW_Attr = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';

    var OSM_Colors_Url  = 'http://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png';
    var OSM_Colors_Attr = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>, Tiles courtesy of <a href="http://hot.openstreetmap.org/" target="_blank">Humanitarian OpenStreetMap Team</a>';

    var ESRI_Colors_Url  = 'http://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
    var ESRI_Colors_Attr = 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community';

    var CARTODB_Black_Url  = 'http://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png';
    var CARTODB_Black_Attr = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>';

    var NASA_Night_Url  = 'http://map1.vis.earthdata.nasa.gov/wmts-webmerc/VIIRS_CityLights_2012/default/{time}/{tilematrixset}{maxZoom}/{z}/{y}/{x}.{format}';
    var NASA_Night_Attr = { attribution: 'Imagery provided by services from the Global Imagery Browse Services (GIBS), operated by the NASA/GSFC/Earth Science Data and Information System (<a href="https://earthdata.nasa.gov">ESDIS</a>) with funding provided by NASA/HQ.',
                          	bounds: [[-85.0511287776, -179.999999975], [85.0511287776, 179.999999975]],
                          	minZoom: 1,
                          	maxZoom: 8,
                          	format: 'jpg',
                          	time: '',
                          	tilematrixset: 'GoogleMapsCompatible_Level'
                          };

    // var grayscale  = L.tileLayer(MAPBOX_Url, {id: 'mapbox.light'  , attribution: MAPBOX_Attr});
    // var streets    = L.tileLayer(MAPBOX_Url, {id: 'mapbox.streets', attribution: MAPBOX_Attr});
    var grayscale  = L.tileLayer(OSM_BW_Url, { attribution: OSM_BW_Attr });
    var streets    = L.tileLayer(OSM_Colors_Url, { attribution: OSM_Colors_Attr });
    var physical   = L.tileLayer(ESRI_Colors_Url, { attribution: ESRI_Colors_Attr });
    var black      = L.tileLayer(CARTODB_Black_Url, { attribution: CARTODB_Black_Attr, subdomains: 'abcd' });
    var night      = L.tileLayer(NASA_Night_Url, NASA_Night_Attr );

    // LEAFLET MAP OBJECT
    var map = L.map('map', {
      center     : [47, 5],
      zoom       : 6,
      layers     : [ grayscale, ME_layer ], // active layers
      zoomControl: false
    });

    // CREATE CONTROLS
    var baseLayers = {
      "Fond de carte gris"         : grayscale,
      // "Fond de carte couleurs"     : streets,
      "Fond de carte terrain seul" : physical,
      "Fond de carte noir"         : black,
      "Fond de carte nuit"         : night
    };

    var active_overlay   = "<span class='lay_ME  lay_radio'> nappes phréatiques</span>" ;
    var inactive_overlay = "<span class='lay_dpt lay_radio'> départements</span><hr>" ;

    var overlays = {
      "<span class='lay_ME  lay_radio'> nappes phréatiques</span>" : ME_layer,
      "<span class='lay_dpt lay_radio'> départements</span><hr>"   : admin_layer,
      // "stations de mesure" : stations_layer_cluster,
      // "préfectures"        : cities_layer,
      "eaux de surface"    : rivers_layer,
    };

    // add zoom control
    var zoom = L.control.zoom( { position : "topright"} )
                        .addTo(map);
    // add scale control
    var scale_bar = L.control.scale( {  position : "bottomright",
                                        imperial : false ,
                                        maxWidth : 250,
                                      } )
                        .addTo(map);
    // add layers control
    // var controls = L.control
    //   .layers( baseLayers, overlays,
    //             { position  : "bottomleft", collapsed : false }
    //           )
    //   .addTo(map);



    // print control
    L.easyPrint({
        title: 'print map',
        position: 'topright',
        elementsToHide: ''
    }).addTo(map);


    // map.on('overlayadd', onOverlayAdd);
    //
    // function onOverlayAdd(e){
    //     console.log("::: onOverlayAdd", e);
    //
    //     active_overlay = e.name;
    //
    // };


    // var div_tooltip_map = d3.select("body").append("div")
    //     .attr("class", "tooltip_map")
    //     .style("opacity", 0);


    // var cities_json ;


    // TOPOJSON HANDLING - TOPOJSON OBJECTS FOR LEAFLET
    L.TopoJSON = L.GeoJSON.extend({
      addData: function(jsonData) {
        if (jsonData.type === "Topology") {
          for (key in jsonData.objects) {
            geojson = topojson.feature(jsonData, jsonData.objects[key]);
            L.GeoJSON.prototype.addData.call(this, geojson);
          }
        }
        else {
          L.GeoJSON.prototype.addData.call(this, jsonData);
        }
      }
    }); // Copyright (c) 2013 Ryan Clark

    // CREATE EMPTY TOPOJSON-LEAFLET OBJECTS
    var topoLayer_water    = new L.TopoJSON();
    var topoLayer_rivers   = new L.TopoJSON();
    var topoLayer_admin    = new L.TopoJSON();
    var topoLayer_stations = new L.TopoJSON();

    var geoLayer_cities    = new L.GeoJSON();

    // VARIABLES DATA / DATA REQUESTS
    var df_ME       = "df_AV_ME"    ;
    var df_dpt      = "df_AV_dpt"   ;
    var df_stations = "df_stations" ;
    var df_rivers   = "df_rivers"   ;

    // default request values for init
    var req_client = "request IO from client";
    var year       = "2007"   ;
    var pest_map   = "XXXXXX" ;
    var categ_map  = "sequential" ;
    var index_map  = "MOYPTOT";
    var index_geom = "TOT_FRANCE" ;
    var radio_tree = "byFunctions" ;
    var dataset_trees ;

    var selected_layer = df_ME ;


    // CREATE GRADIENTS --> CHECK VARIATIONS FROM COLORBREWER
    var scale_limitMid         = {{ colorscaleLimits.limit_middle }} ;
    var scale_limitUp          = {{ colorscaleLimits.limit_up }} ;
    var scale_limitMinus       = {{ colorscaleLimits.limit_minus }} ;

    var scale_limitUp_count    = 100 ;

    var min_value_count        = 0   ;
    var max_value_count        = 100 ;
    var min_max_array_count    = [0, 5, 10, 15, 20, 25, 40, 50, 70, 85, 100 ] ;

    var min_value_concent      = 0.0 ;
    var max_value_concent      = 5.0 ;
    var min_max_array_concent  = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5] ;

    var min_value_diverg        = -3.0 ;
    var max_value_diverg        = 3.0 ;
    var min_max_array_diverg    = [-3.0, -1.0, -0.3, -0.2, -0.1, 0.0, 0.1, 0.2, 0.3, 1.0, 3.0] ;


    // var df_ME_name     = "nappes phréatiques" ;
    // var df_dpt_name    = "départements";
    // var df_rivers_name = "eaux de surface";

    var dict_overlays = {
      "Nappes phréatiques" : df_ME,
      "Départements"       : df_dpt,
      "Eaux de surface"    : df_rivers
    };

    // Overlay layers are grouped
    // cf : https://github.com/ismyrnow/Leaflet.groupedlayercontrol
    var groupedOverlays = {
      "Pesticides par :": {
        "Nappes phréatiques" : ME_layer,
        "Départements"       : admin_layer
      },
      "Autres données :": {
        "Eaux de surface"    : rivers_layer,
      }
    };
    var options = {
      // Make the "pesticides" group exclusive (use radio inputs)
      exclusiveGroups: ["Pesticides par :"],
      // Show a checkbox next to non-exclusive group labels for toggling all
      groupCheckboxes: false,
      position       : "bottomleft",
      collapsed      : false
    };
    // Use the custom grouped layer control, not "L.control.layers"
    var layerControl = L.control.groupedLayers(baseLayers, groupedOverlays, options);
    map.addControl(layerControl);

    // change global variable selected_layer when radio control is checked
    $('[name="leaflet-exclusive-group-layer-1"]').click( function() {
      if ($(this).is(':checked')) {
            console.log("radio layer checked : ", this.id , " = ", dict_overlays[this.id] );
            selected_layer = dict_overlays[this.id]
        }
    });

    // var min_value_ME      = 0.0 ; /////////////////////////////////////////////////
    // var max_value_ME      = 5.0 ; /////////////////////////////////////////////////
    // var min_max_array_ME  = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5]  ; /////////////////////////////////////////////////
    //
    // var min_value_dpt     = 0.0 ; /////////////////////////////////////////////////
    // var max_value_dpt     = 5.0 ; /////////////////////////////////////////////////
    // var min_max_array_dpt = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5]  ; /////////////////////////////////////////////////


    var dft_opacity       = 0.5;
    var dft_weight        = 0.5;
    var dft_rivers_weight = 0.3;
    var dft_null_color    = "#f0f0f0" ;
    var dft_stroke_color  = "white"   ;
    var dft_rivers_color  = "#081d58" ;
    var z_index_dft       = 3 ;







    // choose between  - sequential / divergent / qualitative - colorscales
    function chooseColorScale( seq_div_qual ) {

      if ( seq_div_qual == "sequential" ) {
        var colorScale  = chroma
          .scale( {{ choropleths.seq_beige_blue_red|safe }} )
          .domain( [ 0.0001, scale_limitUp ], 9, 'log' );
      }
      else if ( seq_div_qual == "counts") {
        var colorScale  = chroma
          .scale( {{ choropleths.seq_yel_red|safe }} )
          .domain( [ 0.0, scale_limitUp_count ], 9 );
      }
      else if ( seq_div_qual == "divergent") {
        var colorScale  = chroma
          .scale( {{ choropleths.div_gre_yel_red|safe }} )
          .domain( [ -3.0, 3.0 ], 11 );
      }
      else if (seq_div_qual == "qualitative") {
        var colorScale  = chroma
          .scale( {{ choropleths.qual_12_hard|safe }} )
          .domain( [ 0, 12 ] );
      }
      ;

      return colorScale ;
    };

    function chooseMinMaxArray( seq_div_qual ) {
      if ( seq_div_qual == "sequential" ){
        var min_max_array = min_max_array_concent ;
      }
      else if ( seq_div_qual == "counts" ){
        var min_max_array = min_max_array_count ;
      }
      else if ( seq_div_qual == "divergent" ){
        var min_max_array = min_max_array_diverg ;
      }
      else if ( seq_div_qual == "qualitative" ){
        var min_max_array = min_max_array_count ;
      };

      return min_max_array;
    };

    // function chooseMinMaxArray( req_df ) {
    //   if ( selected_layer == df_ME ){
    //     var min_max_array = min_max_array_ME ;
    //   }
    //   else if ( selected_layer == df_dpt ){
    //     var min_max_array = min_max_array_dpt ;
    //   };
    //   return min_max_array;
    // };

    // CREATE LEGEND
    var legend ; // global empty variable
    //var scale_categ    = "sequential" ;
    //var categ          = "MOYPTOT"    ;


    // create legend control
    function createLegend( seq_div_qual ) {

      var colorScale    = chooseColorScale(  seq_div_qual );
      var min_max_array = chooseMinMaxArray( seq_div_qual );
      // var min_max_array = chooseMinMaxArray( selected_layer );

      //console.log("createLegend / selected_layer :", selected_layer );

      legend = L.control({position: 'bottomright'});

      legend.onAdd = function (map) {

          var div = L.DomUtil.create('div', 'info legend');
          var grades = min_max_array  ;


          if (seq_div_qual == "sequential")  {
            var label = "moyenne des concentrations totales " + "(" + year + ")", unit = "&#181g/L" ;
          }
          else if (seq_div_qual == "counts") {
            if (dict_categs_legend[index_map][pest_map] == undefined){
              var lab_pest = " - " ;
            } else {
              var lab_pest = " : " + dict_categs_legend[index_map][pest_map] ;
            }
            var label = "nombre de pesticides détectés / " + pest_map + lab_pest + " (" + year + ")", unit = "pest." ;
          };

          div.innerHTML += '<p>' + label + '</p>';

          // loop through our density intervals and generate a label with a colored square for each interval
          // first loop for colored legend boxes
          for (var i = 0; i < grades.length; i++) {
              div.innerHTML +=
                  '<span style="background:' + colorScale(grades[i]) + '; opacity:' + dft_opacity + '"></span> ';
          }
          // a line break
          div.innerHTML += '<br>';

          // second loop for text
          for (var i = 0; i < grades.length; i++) {
              div.innerHTML +=
                  '<label>' + (grades[i + 1] ? '<=' + grades[i]  : '>=' + grades[i] ) + '</label>';
          }
          div.innerHTML += '<label>' + unit + '</label>';

          if (selected_layer == df_ME) {
            div.innerHTML += "<br><hr><h6 class='' margin-top='5px'><small>* les nappes d'eau souterraines sont représentées avec un degré de transparence <br> et peuvent parfois se superposer sur la carte si elles sont à des profondeurs (niveaux) différentes</small></h6>";
          };

          return div;
      };

      legend.addTo(map);

    };


    // VIZUALISATION OF DATA ON LAYERS
    function handleLayer(layer, value_fill, req_df, seq_div_qual, z_index ){


      // layer.setZIndex(10); // not working (just works on Tiles)


      var stroke_color  = dft_stroke_color ;
      var stroke_weight = dft_weight ;

      // ignore null values when coloring
      if (value_fill != null ){

        //fillOpacity = ( dft_opacity * value_fill / max_value ) + 0.1 ;
        fillOpacity = dft_opacity  ;

        var colorScale = chooseColorScale( seq_div_qual );
        var fillColor  = colorScale(value_fill).hex();

      }

      else { /// <-- rivers for now
        var fillColor   = dft_null_color ;
        var fillOpacity = 0 ;
        stroke_color    = dft_rivers_color  ;
        stroke_weight   = dft_rivers_weight ;
      }

      //layer.bindpopup()
      layer.setStyle({
        fillColor  : fillColor,
        fillOpacity: fillOpacity,
        color      : stroke_color,
        weight     : stroke_weight,
        opacity    : 1
      });

      if (req_df != df_rivers ) {
        layer.on({
          mouseover: enterLayer,
          mouseout : leaveLayer,
          click    : zoomToFeature
        });
      };
    };

    function enterLayer(e){
      //this.bringToFront();
      this.setStyle({
        weight : dft_weight + 3,
        opacity: 1
      });

      //   div_tooltip_map.transition()
      //       .duration(200)
      //       .style("opacity", .9);
      //   div_tooltip_map.html(" test : " + e.target.feature.properties.NomMasseDE + "<br>" )
      //       .style("left", (d3.event.pageX - 30) + "px")
      //       .style("top",  (d3.event.pageY - 30) + "px")
    };

    function leaveLayer(e){
      //this.bringToBack();
      this.setStyle({
        weight : dft_weight,
        opacity: dft_opacity
      });

      // div_tooltip_map.transition()
      //     .duration(500)
      //     .style("opacity", 0);
      // div_tooltip_map.html("")
      //     .style("left", "0px")
      //     .style("top",  "0px");

      // rivers_layer.eachLayer( function(layer) {
      //   layer.bringToBack()
      //});
    };

    function zoomToFeature(e) {

      //map.fitBounds(e.target.getBounds());
      var props = e.target.feature.properties ;
      //console.log("zoomToFeature / props : ", props);

      //toggleSidebarInfos();
      displayInfos(props);

    };

    // display infos on click
    var toggledLast ;

    var root_ME_SANDRE = "http://www.sandre.eaufrance.fr/fiche-geo?id=rdytcq/dataset/244/MasseDEauSouterraine/" ;

    var ME_infos_dict = {
      "Karstique" : { "def"     : "Le caractère karstique est attribué aux masses d’eau souterraine qui comportent des karsts actifs, fonctionnels (fonctionnement hydraulique particulier avec une organisation spécifique du drainage). Les masses d’eau de ce type sont caractérisées par la présence de zones de surface d’une extrême vulnérabilité et des écoulements souterrains particulièrement rapides",
                      "def_val" : {"N": "non", "Y" : "oui"},
                      "link"    : "http://www.sandre.eaufrance.fr/squelettes/consulter_fiche_attribut.php?dictionnaire=/db/sandre/Schemas/mdo/1.2/sandre_fmt_xml_mdo.xsd&entite=MasseDEauSouterraine&attribut=Karstique",
                    },
      "Niveau"    : { "def"     : "Dans le cas où 2 ou plusieurs masses d'eau souterraine sont superposées, l'attribut niveau permet de positionner les masses d'eau les une par rapport aux autres pour le polygone élémentaire concerné. La masse d'eau la plus profonde ayant le niveau le plus élevé. Le niveau commence à 1",
                      "def_val" : { "0" : "",
                                    "1" : "",
                                    "2" : ""
                                  },
                      "link"    : "",
                    },
      "FrangeLitt" : {"def"     : "Les masses d’eau côtières et insulaires en relation avec l’eau de mer peuvent, en raison d’une surexploitation chronique ou temporaire (forte augmentation estivale des captages AEP), induire un risque d’intrusion saline des aquifères",
                      "def_val" : {"N": "non", "Y" : "oui"},
                      "link"    : "http://www.sandre.eaufrance.fr/squelettes/consulter_fiche_attribut.php?dictionnaire=/db/sandre/Schemas/mdo/1.2/sandre_fmt_xml_mdo.xsd&entite=MasseDEauSouterraine&attribut=FrangeLittorale",
                    },
      "TypeMasseD" : {"def"     : "Les classes de masse d’eau souterraine sont définies par l’arrêté du 12 janvier 2010 (publié au JORF n.0027 du 2 février 2010) relatif aux méthodes et aux critères à mettre en œuvre pour délimiter et classer les masses d'eau et dresser l'état des lieux prévu à l'article R. 212-3 du code de l'environnement.",
                      "def_val" : { "A"  : "Alluvial",
                                    "DS" : "Dominante sédimentaire non alluviale",
                                    "EV" : "Edifice volcanique",
                                    "IP" : "Système hydraulique composite propre aux zones intensément plissées de montagne",
                                    "S"  : "Socle",
                                    "IL" : "Imperméable localement"
                                  },
                      "link"    : "http://www.sandre.eaufrance.fr/squelettes/consulter_fiche_attribut.php?dictionnaire=/db/sandre/Schemas/mdo/1.2/sandre_fmt_xml_mdo.xsd&entite=MasseDEauSouterraine&attribut=TypeMasseDEauSouterraine",
                    },
      "NatureEcou" : {"def"     : "La nature des écoulements d’une masse d’eau souterraine est définie par l’arrêté du 12 janvier 2010 (publié au JORF n.0027 du 2 février 2010) relatif aux méthodes et aux critères à mettre en œuvre pour délimiter et classer les masses d'eau et dresser l'état des lieux prévu à l'article R. 212-3 du code de l'environnement.",
                      "def_val" : { "0" : "Inconnu",
                                    "1" : "Entièrement libre",
                                    "2" : "Entièrement captif",
                                    "3" : "Une ou des partie(s) libre(s) et une ou des partie(s) captive(s), les écoulements sont majoritairement libres",
                                    "4" : "Une ou des partie(s) libre(s) et une ou des partie(s) captive(s), les écoulements sont majoritairement captifs",
                                  },
                      "link"    : "http://www.sandre.eaufrance.fr/squelettes/consulter_fiche_attribut.php?dictionnaire=/db/sandre/Schemas/mdo/1.2/sandre_fmt_xml_mdo.xsd&entite=MasseDEauSouterraine&attribut=NatureEcoulement",
                    },
    };

    function displayInfos(props) {

      // close sidebar
      if (toggledLast == props | toggled == -1 ) {

        $("#collapseInfosNappe").collapse('hide');
        //$("#collapseInfosPest").collapse('hide');

        toggleSidebarInfos();

      }

      // do nothing on sidebar and display infos
      else {

        toggledLast = props ;

        badge  = "<span class='badge'>";
        badge_ = "</span>"

        d3.select('#MOYPTOT').html( badge + props.MOYPTOT.XXXXXX + " &#181g/L");

        var pest = " pesticides différents détectés" ;

        d3.select('#nbr_F').html( badge + props.FUNCTIONS.F + badge_ + pest);
        d3.select('#nbr_I').html( badge + props.FUNCTIONS.I + badge_ + pest);
        d3.select('#nbr_H').html( badge + props.FUNCTIONS.H + badge_ + pest);

        d3.select('#nbr_divorg').html( badge + props.FAMILLES["Divers (organiques)"] + badge_ + pest);
        d3.select('#nbr_urees').html(  badge + props.FAMILLES["Urées"] + badge_ + pest);
        d3.select('#nbr_azo').html(    badge + props.FAMILLES["Azoles"] + badge_ + pest);
        d3.select('#nbr_orgchl').html( badge + props.FAMILLES["Organochlorés"] + badge_ + pest);
        d3.select('#nbr_triaz').html(  badge + props.FAMILLES["Triazines et métabolites"] + badge_ + pest);

        d3.select('#nbr_tIa').html( badge + props.TYPES["Ib"] + badge_ + pest);
        d3.select('#nbr_tIb').html( badge + props.TYPES["Ib"] + badge_ + pest);
        d3.select('#nbr_tII').html( badge + props.TYPES["II"] + badge_ + pest);


        //console.log(props);
        if ( selected_layer == df_ME ) {

          //var ME_name = props.NomMasseDE.toLowerCase() ;

          d3.select('#sb_title').html( props.NomMasseDE ); //+ " (" + props.CdMasseDEa + ")");
          d3.select('#rep_pest_code').html( "la masse d'eau " + props.CdMasseDEa );

          d3.select('#reqTree_ME_dpt').attr("reqvalue", props.CdMasseDEa);

          d3.select('#CdMasseDEa').html( props.CdMasseDEa )
                                  .attr( "href", root_ME_SANDRE + props.CdMasseDEa );

          // d3.select('#NomMasseDE').html(props.NomMasseDE);

          d3.select('#Niveau_').attr( "title", ME_infos_dict["Niveau"]["def"] );
          d3.select('#Niveau').html(  props.Niveau );
          d3.select('#TypeMasseD_').attr( "title", ME_infos_dict["TypeMasseD"]["def"] );
          d3.select('#TypeMasseD').html( ME_infos_dict["TypeMasseD"]["def_val"][props.TypeMasseD] )
                                  .attr( "href", ME_infos_dict["TypeMasseD"]["link"] );
          // d3.select('#TypeMasseD').html( props.TypeMasseD );
          d3.select('#Karstique_').attr( "title", ME_infos_dict["Karstique"]["def"] );
          d3.select('#Karstique').html(  ME_infos_dict["Karstique"]["def_val"][props.Karstique] )
                                  .attr( "href", ME_infos_dict["Karstique"]["link"] );
          // d3.select('#Karstique').html(  props.Karstique );
          d3.select('#FrangeLitt_').attr( "title", ME_infos_dict["FrangeLitt"]["def"] );
          d3.select('#FrangeLitt').html( ME_infos_dict["FrangeLitt"]["def_val"][props.FrangeLitt] )
                                  .attr( "href", ME_infos_dict["FrangeLitt"]["link"] );
          // d3.select('#FrangeLitt').html( props.FrangeLitt );
          d3.select('#NatureEcou_').attr( "title", ME_infos_dict["NatureEcou"]["def"] );
          d3.select('#NatureEcou').html( ME_infos_dict["NatureEcou"]["def_val"][props.NatureEcou] )
                                  .attr( "href", ME_infos_dict["NatureEcou"]["link"] );

          d3.select('#FONCTIONS').html( props.FUNCTIONS );

          // d3.select('#pest_proportions').html(props.CdMasseDEa);


          //$("#collapseInfosNappe").collapse('show');

          $("#collapseInfosPest").collapse('show');

          $("#collapserInfosNappe").prop("disabled", false);
          $("#collapseInfosNappe").collapse('show');

        } else if (selected_layer == df_dpt) {

          //var dpt_name = props.nom.toUpperCase() ;

          d3.select('#sb_title').html( props.nom + " (" + props.code + ")" );
          d3.select('#rep_pest_code').html( "le département " + props.code );

          d3.select('#reqTree_ME_dpt').attr("reqvalue", props.code);

          //hide and disable infos nappe
          $("#collapseInfosNappe").collapse('hide');
          $("#collapserInfosNappe").prop("disabled", true);

          $("#collapseInfosPest").collapse('show');

          // d3.select('#pest_proportions').html(props.nom);

        };

        //$("#collapseInfosPest").collapse('show');
        //$("#collapseInfosNappe").collapse('show');

      }

    };

    // refresh min-max values
    // function refreshMinMax_MOYPTOT ( req_df_, data_minmax ) {
    //
    //   new_min    = data_minmax.min ;
    //   new_max    = data_minmax.max ;
    //   new_minmax = data_minmax.min_max_array ;
    //
    //   // update min_max arrays
    //   if ( req_df_ == df_ME ){
    //     min_max_array_ME = new_minmax ;
    //     max_value_ME     = new_max ;
    //     min_value_ME     = new_min ;
    //   }
    //   else if ( req_df_ == df_dpt ){
    //     min_max_array_dpt = new_minmax ;
    //     max_value_dpt     = new_max ;
    //     min_value_dpt     = new_min ;
    //   } ;
    //
    //   console.log("refreshMinMax_MOYPTOT / new_minmax :", new_minmax );
    //
    // };


    // refresh legend scale
    function refreshLegend ( req_df_, seq_div_qual ) {

      console.log("refreshLegend " );
      //console.log("refreshLegend / legend :", legend );

      // new_min    = data_minmax.min ;
      // new_max    = data_minmax.max ;
      // new_minmax = data_minmax.min_max_array ;
      //
      // // update min_max arrays
      // if ( req_df_ == df_ME ){
      //   min_max_array_ME = new_minmax ;
      //   max_value_ME     = new_max ;
      //   min_value_ME     = new_min ;
      // }
      // else if ( req_df_ == df_dpt ){
      //   min_max_array_dpt = new_minmax ;
      //   max_value_dpt     = new_max ;
      //   min_value_dpt     = new_min ;
      // } ;
      //
      // console.log("refreshLegend / new_minmax :", new_minmax );

      // refresh legend only if it corresponds to selected layer
      if ( req_df_ == selected_layer ){

        // remove previous legend if already exists
        if (legend != undefined) {
          legend.remove();
          //console.log("refreshLegend / legend.remove() ");
        };

        // recreate a legend choosing between sequential / divergent / qualitative
        createLegend( seq_div_qual ) ;

      };
    };

    // update layer data
    function refreshTopoLayer ( req_df, dataset ) {

      if ( req_df == df_ME )       { topoLayer = topoLayer_water; }
      else if ( req_df == df_dpt ) { topoLayer = topoLayer_admin; }
      else                         { topoLayer = topoLayer_rivers; };

      console.log("refreshTopoLayer / start for req_df :", req_df );

      topoLayer.eachLayer(

        function(layer) {

          if (req_df == df_ME) {
            var index_geom = layer.feature.properties.CdMasseDEa ;
            //console.log(" io_slice_from_server / index_ME : ", index_ME)
          } else if (req_df == df_dpt) {
            var index_geom = layer.feature.properties.code ;
          } else {
            var index_geom = null ;
          };

          var data_L_MOYPTOT         = dataset["MOYPTOT"][ index_geom ] ;
          //var data_L_MOYPTOT_all_CAS = _.pickBy(dataset["MOYPTOT_all_CAS"][ index_geom ]) ; // using LoDash to skip null values
          //var data_L_MOYPTOT_all_CAS = _.omitBy(dataset["MOYPTOT_all_CAS"][ index_geom ], _.isNil ) ; // using LoDash to skip null values
          var data_L_FUNCTIONS       = dataset["FUNCTIONS"][ index_geom ] ;
          var data_L_FAMILLES        = dataset["FAMILLES"][ index_geom ] ;
          var data_L_TYPES           = dataset["TYPES"][ index_geom ] ;

          layer.feature.properties.MOYPTOT         = data_L_MOYPTOT ;
          //layer.feature.properties.MOYPTOT_all_CAS = data_L_MOYPTOT_all_CAS ;
          layer.feature.properties.FUNCTIONS       = data_L_FUNCTIONS ;
          layer.feature.properties.FAMILLES        = data_L_FAMILLES ;
          layer.feature.properties.TYPES           = data_L_TYPES ;

        }
      );
    };

    // refresh map : colors and scale
    function refreshMap ( req_df, index_map, req_query, seq_div_qual ) {

      console.log("refreshMap / start for req_df :", req_df );

      // choose topolayer
      if ( req_df == df_ME  )      {
        topoLayer = topoLayer_water;

        // sort layers by Niveau --> draw higher (deeper) first
        // console.log("refreshMap / sort topoLayer...");
        //
        //console.log( topoLayer );
      }
      else if ( req_df == df_dpt ) { topoLayer = topoLayer_admin; }
      else                         { topoLayer = topoLayer_rivers; };

      // iterate and update map
      topoLayer.eachLayer(

        function(layer) {


          if      (index_map == "MOYPTOT")         { value_ = layer.feature.properties.MOYPTOT   }
          //if      (index_map == "MOYPTOT_all_CAS") { value_ = layer.feature.properties.MOYPTOT_all_CAS  }
          else if (index_map == "FUNCTIONS")       { value_ = layer.feature.properties.FUNCTIONS }
          else if (index_map == "FAMILLES")        { value_ = layer.feature.properties.FAMILLES  }
          else if (index_map == "TYPES")           { value_ = layer.feature.properties.TYPES     } ;

          // handle missing data
          //console.log( layer.feature.properties.CdMasseDEa , value_);

          if (value_ != null ){
            if ( req_query in value_ ) {
              value_fill = value_[ req_query ]
            }
            else {
              value_fill = null
            }
          } else {
            value_fill = null
          };

          //console.log( value_[ req_query ]);
          //console.log( value_fill );

          //console.log("refreshMap / value_fill :", value_fill );

          // set z_index of current layer if
          var z_index = z_index_dft;


          handleLayer( layer, value_fill , req_df, seq_div_qual, z_index );

        });

    };

    // var queue = d3_queue.queue(1);
    // queue
    //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.water ) }}" ) // topojson water
    //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.admin ) }}" ) // topojson admin
    //   .awaitAll(InitMap_) ;

    //// InitMap as callback function --> first to run then (callback)

    //function InitMap () {
    //InitMap = function (callback) {
    function InitMap (callback) {

      //var def = new $.Deferred();

      // GET TOPOJSON FILES
      $.getJSON( "{{ url_for ( 'static', filename = basemaps.ME ) }}" )
        .done(addTopoData_ME);
      $.getJSON( "{{ url_for( 'static', filename  = basemaps.admin ) }}" )
         .done(addTopoData_admin);
      $.getJSON( "{{ url_for( 'static', filename  = basemaps.rivers ) }}" )
        .done(addTopoData_rivers);

      //load main cities /////////////////////////////////////////////
      // $.getJSON( "{{ url_for( 'static', filename  = basemaps.cities ) }}" )
      //   .done(addGeoDataCities);

      // LOAD CITIES DATAS
      function addGeoDataCities(geooData){
        console.log(" - leaflet -- starting / addGeoDataCities ");
        console.log(" - leaflet -- addGeoDataCities / datas : ", geooData);
        geoLayer_cities.addData(geooData);
        geoLayer_cities.addTo(cities_layer);

        geoLayer_cities.eachLayer(
          function (layer) {
            //handleLayer(layer, null , df_rivers);
            layer.bringToFront();
          });

        console.log(" - leaflet -- finished / addGeoDataCities ");

      };

      // PROCESS TOPOJSON // WARNING : OVERWRITES previous TOPOLAYER object
      function addTopoData_ME(topoData){
        console.log(" - leaflet -- starting / addTopoData_ME ");
        topoLayer_water.addData(topoData);
        topoLayer_water.addTo(ME_layer);
        console.log(" - leaflet -- finished / addTopoData_ME ");

        callback(); // <-- callback inside last called function
      };

      function addTopoData_admin(topoData){
        console.log(" - leaflet -- starting / addTopoData_admin ");
        topoLayer_admin.addData(topoData);
        topoLayer_admin.addTo(admin_layer);
        console.log(" - leaflet -- finished / addTopoData_admin ");
      };

      function addTopoData_rivers(topoData){
        console.log(" - leaflet -- starting / addTopoData_rivers ");
        topoLayer_rivers.addData(topoData);
        topoLayer_rivers.addTo(rivers_layer);

        //topoLayer_rivers.eachLayer(handleLayer); /////////////////////////////////////
        topoLayer_rivers.eachLayer(
          function (layer) {
            handleLayer(layer, null , df_rivers, z_index_dft);
            layer.bringToBack();
          }
        );

        console.log(" - leaflet -- finished / addTopoData_rivers ");
        console.log("");

      };


      //return def.promise();

    }; // <-- end : InitMap


    // START ConnectSocketIO = function () {
    function ConnectSocketIO () {


      // INITIATE SOCKET IO CONNECTION
      var socket = io.connect('http://' + document.domain + ':' + location.port);

      // EMIT REQUEST SLICE TO SERVER
      function EmitRequestSlice(df_name) {

        console.log(" *** EmitRequestSlice / df_name : ", df_name);

        //$('#mod_loader').modal('show');
        $(".progress").removeClass("nobar");

        socket.emit(
          'io_request_slice', {
            msg                 : req_client ,
            df_source           : df_name ,
            slice_query_index   : [ year, pest_map ] ,
            slice_query_columns : [ ]
          }
        );
      };

      // EMIT REQUEST TREE TO SERVER
      function EmitRequestTree(df_name, area ) {
        console.log(" *** EmitRequestTree / df_name : ", df_name, " - area : ", area);
        socket.emit(
          'io_request_tree', {
            msg                 : req_client ,
            df_source           : df_name ,
            slice_query_index   : [ year, pest_map ] ,
            slice_query_columns : area
          }
        );
      };

      // INITIATE MAP DATAS ON CONNECTION
      socket.on('connect', function() {
        // socket.emit('connection start', {data: '--> client connected from : ' + document.domain + ':' + location.port });

        //$('#mod_loader').modal('show');

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        //EmitRequestTree(df_ME, index_geom );

      });


      // progress bar
      // function progressBar(state) {
      //   console.log("progressBar / received",state.reveived);
      //   console.log("progressBar / received",state.reveived);
      //   console.log("progressBar / received",state.reveived);
      //   console.log("progressBar / received",state.reveived);
      // };


      // IO - REFRESH DATAS AND MAP WHEN RECEIVING NEW DATA
      socket.on('io_slice_from_server', function( data_slice ) {

        //var req_query            = pest ; //data_slice.request_query   ; // "XXXXXX" for instance

        console.log(" *** io_slice_from_server / data_slice (raw) : "  ) //, " - req_query : ", req_query ) ;
        //console.log(data_slice);

        var data_MOYPTOT         = data_slice.slice_MOYPTOT.data    ;
        //var data_MOYPTOT_minmax  = data_slice.slice_MOYPTOT.min_max ;

        //var data_MOYPTOT_all_CAS = data_slice.slice_MOYPTOT_all_CAS.data    ;

        var data_FUNCTIONS       = data_slice.slice_FUNCTIONS.data ;
        var data_FAMILLES        = data_slice.slice_FAMILLES.data  ;
        var data_TYPES           = data_slice.slice_TYPES.data     ;

        //var seq_div_qual         = data_slice.seq_div_qual    ;
        var req                  = data_slice.request_sent    ;
        var req_df_              = req.df_source              ;

        //console.log(" io_slice_from_server / req : ", req) ;
        console.log(" *** io_slice_from_server / req_df_ : "    , req_df_ ) //, " - req_query : ", req_query ) ;
        //console.log(" io_slice_from_server / data_minmax : ", data_MOYPTOT_minmax) ;



        // parse data from JSON
        var data_MOYPTOT_json         = JSON.parse(data_MOYPTOT) ;
        //var data_MOYPTOT_all_CAS_json = JSON.parse(data_MOYPTOT_all_CAS) ;
        var data_FUNCTIONS_json       = JSON.parse(data_FUNCTIONS) ;
        var data_FAMILLES_json        = JSON.parse(data_FAMILLES) ;
        var data_TYPES_json           = JSON.parse(data_TYPES) ;



        var dataset = {
          "MOYPTOT"         : data_MOYPTOT_json,
          //"MOYPTOT_all_CAS" : data_MOYPTOT_all_CAS_json,
          "FUNCTIONS"       : data_FUNCTIONS_json,
          "FAMILLES"        : data_FAMILLES_json,
          "TYPES"           : data_TYPES_json
        };

        // set global vars for TOT_FRANCE for treemap
        //var MOYPTOT_FR   = data_MOYPTOT_json["TOT_FRANCE"] ;
        var FUNCTIONS_FR = data_FUNCTIONS_json["TOT_FRANCE"] ;
        var FAMILLES_FR  = data_FAMILLES_json["TOT_FRANCE"] ;
        var TYPES_FR     = data_TYPES_json["TOT_FRANCE"] ;


        // refresh in ordrer : MINMAX -> LEGEND -> TOPOLAYER --> MAP
        //refreshMinMax_MOYPTOT ( req_df_, data_MOYPTOT_minmax ) ;
        refreshLegend(          req_df_, categ_map ) ;
        refreshTopoLayer(       req_df_, dataset );
        // refreshMap (            req_df_, "MOYPTOT_all_CAS", req_query, seq_div_qual );
        refreshMap (            req_df_, index_map, pest_map, categ_map );

        $('#mod_loader').modal('hide');
        $(".progress").addClass("nobar");

        console.log("");

      }); // <-- end : io_slice_from_server


      // IO - REFRESH DATAS AND TREEMAP WHEN RECEIVING NEW DATA
      socket.on('io_tree_from_server', function ( tree_pests ) {

        // console.log( " *** io_tree_from_server", tree_pests );

        var tree_FAMILLES  = JSON.parse(tree_pests.tree_FAMILLES) ;
        var tree_FUNCTIONS = JSON.parse(tree_pests.tree_FUNCTIONS) ;
        var tree_TYPES     = JSON.parse(tree_pests.tree_TYPES) ;

        console.log( " *** io_tree_from_server / tree_FAMILLES" );
        //console.log(tree_FAMILLES);

        dataset_trees = {
          "byFamilies"  : tree_FAMILLES,
          "byFunctions" : tree_FUNCTIONS,
          "byTypes"     : tree_TYPES,
        };

        // makeTreeMap (tree_FUNCTIONS);
        // d3.select('#pest_proportions').html(index_geom);
        d3.select('#pest_proportions').html(function () { return index_geom=="TOT_FRANCE" ? "toute la France" : index_geom } );
        makeTreeMap ( dataset_trees, radio_tree );

      }); // <-- end : io_tree_from_server


      // SWITCH TREE CATEGORY
      $(".switchCategTree").on("click", function() {

        categ_tree = $(this).attr("value") ;

        console.log("switchCategTree / categ_tree : " , categ_tree) ;

        radio_tree = categ_tree ;
        makeTreeMap ( dataset_trees, radio_tree )

      });


      // REQUEST BUTTONS
      $('.request').on('click', function() {

        var req_value = $(this).attr("reqvalue");
        var req_type  = $(this).attr("reqtype") ;

        console.log( "req_type : " + req_type + " / " + req_value ) //+ " (" + jQuery.type(req_value) + ")" );

        if ( req_type == "year") {
          year = req_value ;
        }

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        EmitRequestTree(df_ME, index_geom ); //////////////

      });


      // SLIDER YEARS
      $(".slider_years").on("input change", function() {

        //console.log(this) ;

        var year_slide = this.value ;

        console.log("slider_years / year : ", year_slide) ;

        document.querySelector('#annee_selected').value  = year_slide ;
        document.querySelector('#annee_selected2').value = year_slide ;

        var req_value = year_slide ;
        var req_type  = "year";

        // console.log( "req_type : " + req_type + " / " + req_value + " (" + jQuery.type(req_value) + ")" );
        if ( req_type == "year") {
          year = req_value ;
        }

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        // EmitRequestTree(df_ME, index_geom);
        EmitRequestTree(selected_layer, index_geom);

        $(".slider_years").val(year_slide) ;
        //$(".slider_years").slider('refreh') ;

        //displayInfos(toggledLast) ;

      });


      // BUTTONS FOR COUNTS : FUNCTIONS / FAMILLES / TYPES
      $(".switchmap").on("click", function() {

        //console.log(this) ;

        var req_value = $(this).attr("reqvalue"); // ex.
        var req_type  = $(this).attr("reqtype") ; // ex.

        if ( req_type == "MOYPTOT" ) { categ_map = "sequential" }
        else                         { categ_map = "counts" };

        var req_df_ = selected_layer   ; /////////

        index_map = req_type  ;
        pest_map  = req_value ;

        console.log("switchmap / req_value : ", req_value , " / req_type : ", req_type, " / req_df_ : ", req_df_ ) ;

        refreshLegend( req_df_, categ_map ) ;
        // refreshMap (   req_df_, index_map, pest_map, categ_map );

        // refresh dpt and ME layers always together
        refreshMap (   df_ME , index_map, pest_map, categ_map );
        refreshMap (   df_dpt, index_map, pest_map, categ_map );

        console.log("");

      });


      // UPDATE TREEMAP
      $(".switchtree").on("click", function() {

        //console.log(this) ;

        var req_value = $(this).attr("reqvalue"); // ex.

        index_geom = req_value;
        area       = req_value ;

        console.log("switchtree / req_value : ", req_value ) ;

        //EmitRequestTree( selected_layer, area ) //////////////////////////////////////////
        EmitRequestTree( selected_layer, area ) //////////////////////////////////////////

      });


      EmitRequestSlice(df_ME);
      EmitRequestSlice(df_dpt);


      // map.on('baselayerchange', function(e) {
      //   console.log(" :::: baselayerchange  : ");
      // });

      // $("[name='leaflet-base-layers']").change( function () {
      //     alert('Layers selected: ' + $(this).parent().text());
      // });

    }; // <-- end : ConnectSocketIO


  $(document).ready(function() { // <-- place at top to run stuff in order


    //$('#mod_intro').modal('toggle');

    //InitMap().then(ConnectSocketIO); // <-- with defer
    //ConnectSocketIO();
    InitMap( ConnectSocketIO ); // <-- with callback

    console.log(" - InitMap / finished ");
    console.log(" ");

    // change control layer to radio buttons
    // $('.lay_radio').parent().parent().input.attr("type", "radio");



  }); //<-- end : $(document).ready



}); // <-- end : $(window).load


</script>
