
<style>

  /* MAP CSS */
  #content {
    padding-left: 0px;
    padding-right: 0px;
  }
  html,body,#map{
    /*height : 90%;*/
    width  : 100%;
    z-index: 1;
  }

  div .leaflet-control-container .leaflet-top {
    top: 20px;
  }


  div .leaflet-control-zoom {
    display: inline-flex;

  }
  div .leaflet-bar a:first-child {
    border-top-right-radius: 0px;
    border-top-left-radius: 4px;
    border-bottom-right-radius: 0px;
    border-bottom-left-radius: 4px;
    border-bottom : none;
    border-right : 1px solid #ccc ;
  }
  div .leaflet-bar a:last-child {
    border-top-right-radius: 4px;
    border-top-left-radius: 0px;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 0px;
  }


  .info {
      padding: 6px 8px;
      font: 14px/16px Arial, Helvetica, sans-serif;
      background: white;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 5px;
  }
  .info h4 {
      margin: 0 0 5px;
      color: #777;
  }

  .legend span, .legend label {
  display: block;
  width: 40px;
  height: 15px;
  float: left;
  /*opacity: 0.7;*/
  text-align: center;
  font-size: 80%
  }

  .tooltip_map {
      position  : absolute;
      text-align: center;
      color : white;
      width : 100px;
      height: auto;
      padding: 2px;
      font   : 10px sans-serif;
      background: #7841a9 ;
      opacity: .8;
      border : 0px;
      border-radius : 3px;
      pointer-events: none;
      z-index : inherit;
  }

</style>


<div id="map" style="position: fixed;"></div>

<!-- CHROMA JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/chroma-js/0.5.9/chroma.min.js"></script>

<!-- MARKER CLUSTER -->
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.Default.css" />
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.css" />
<script type='text/javascript' src='https://unpkg.com/leaflet.markercluster@1.0.0/dist/leaflet.markercluster.js'></script>


<script>


  var dict_categs_legend = {
    "FUNCTIONS" : { "H"   : "herbicides",
                    "I"   : "insecticides" ,
                    "F"   : "fongicides",
                    "I,A" : "insecticides, acaricides",
                    "Reg" : "régulateurs de croissance",
                    "I,N" : "insecticides, nématicides",
                    "F,N" : "fongicides, nématicides",
                    "Ro"  : "rodenticides",
                    "I,A,F,H" : "insecticides, acaricides, fongicides, herbicides",
                    "I,Reg" : "insecticides, régulateurs de croissance",
                    "I,A,M" : "insecticides, acaricides, mollusticides",
                    "RepO"  : "répulsif",
                    "no ref": "fonction non identifiée"
                    },
    "FAMILLES"  : {},
    "TYPES"     : { "I"     : "toxique",
                    "II"    : "modérément toxique",
                    "III"   : "légèrement toxique",
                    "no ref": "dangerosité non identifiée"
                    }
  };



  // CHECK WINDOW SIZE
  $(window).load(function() {

    var window_w = window.innerWidth;
    var window_h = window.innerHeight;
    var navbar_h = $('header').outerHeight();
    var map_h    = window_h - navbar_h ;
    console.log( "window_w : ", window_w," - window_h : ", window_h, " - navbar_h : ", navbar_h );
    // return desired height to map
    $('#map').css({"height": map_h});

    // CREATE EMPTY LAYERS GROUPS
    var ME_layer     = new L.layerGroup();
    var rivers_layer = new L.layerGroup();
    var admin_layer  = new L.layerGroup();
    var cities_layer = new L.layerGroup();

    //var stations_layer = new L.layerGroup();
    var stations_layer_cluster = L.markerClusterGroup({
        spiderfyOnMaxZoom: false,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });

    // BASEMAP TILES
    var mbAttr = 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
      '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
      'Imagery <a href="http://mapbox.com">Mapbox</a>';
    var mbUrl  = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw';

    var grayscale  = L.tileLayer(mbUrl, {id: 'mapbox.light'  , attribution: mbAttr});
    var streets    = L.tileLayer(mbUrl, {id: 'mapbox.streets', attribution: mbAttr});

    // LEAFLET MAP OBJECT
    var map = L.map('map', {
      center     : [47, 3],
      zoom       : 6,
      layers     : [ grayscale, ME_layer, cities_layer ], // active layers
      zoomControl:false
    });

    // CREATE CONTROLS
    var baseLayers = {
      "Fond gris": grayscale,
      "Fond OSM" : streets
    };

    var overlays = {
      "nappes phréatiques" : ME_layer,
      "départements"       : admin_layer,
      // "stations de mesure" : stations_layer_cluster,
      "eaux de surface"    : rivers_layer,
      // "préfectures"        : cities_layer,
    };

    var zoom     = L.control.zoom( { position : "topright"} ).addTo(map);
    var controls = L.control.layers(
      baseLayers, overlays,
      { position : "bottomleft" }
    ).addTo(map);


    // var div_tooltip_map = d3.select("body").append("div")
    //     .attr("class", "tooltip_map")
    //     .style("opacity", 0);


    var cities_json ;


    // TOPOJSON HANDLING - TOPOJSON OBJECTS FOR LEAFLET
    L.TopoJSON = L.GeoJSON.extend({
      addData: function(jsonData) {
        if (jsonData.type === "Topology") {
          for (key in jsonData.objects) {
            geojson = topojson.feature(jsonData, jsonData.objects[key]);
            L.GeoJSON.prototype.addData.call(this, geojson);
          }
        }
        else {
          L.GeoJSON.prototype.addData.call(this, jsonData);
        }
      }
    }); // Copyright (c) 2013 Ryan Clark

    // CREATE EMPTY TOPOJSON-LEAFLET OBJECTS
    var topoLayer_water    = new L.TopoJSON();
    var topoLayer_rivers   = new L.TopoJSON();
    var topoLayer_admin    = new L.TopoJSON();
    var topoLayer_stations = new L.TopoJSON();

    var geoLayer_cities    = new L.GeoJSON();

    // VARIABLES DATA / DATA REQUESTS
    var df_ME       = "df_AV_ME"    ;
    var df_dpt      = "df_AV_dpt"   ;
    var df_stations = "df_stations" ;
    var df_rivers   = "df_rivers"   ;

    // default request values for init
    var req_client = "request IO from client";
    var year       = "2007"   ;
    var pest_map   = "XXXXXX" ;
    var categ_map  = "sequential" ;
    var index_map  = "MOYPTOT";
    var index_geom = "TOT_FRANCE" ;
    var radio_tree = "byFunctions" ;
    var dataset_trees ;

    // CREATE GRADIENTS --> CHECK VARIATIONS FROM COLORBREWER
    var scale_limitMid         = {{ colorscaleLimits.limit_middle }} ;
    var scale_limitUp          = {{ colorscaleLimits.limit_up }} ;
    var scale_limitMinus       = {{ colorscaleLimits.limit_minus }} ;

    var scale_limitUp_count    = 100 ;

    var min_value_count        = 0   ;
    var max_value_count        = 100 ;
    var min_max_array_count    = [0, 5, 10, 15, 20, 25, 40, 50, 70, 85, 100 ] ;

    var min_value_concent      = 0.0 ;
    var max_value_concent      = 5.0 ;
    var min_max_array_concent  = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5] ;

    var min_value_diverg        = -3.0 ;
    var max_value_diverg        = 3.0 ;
    var min_max_array_diverg    = [-3.0, -1.0, -0.3, -0.2, -0.1, 0.0, 0.1, 0.2, 0.3, 1.0, 3.0] ;




    // var min_value_ME      = 0.0 ; /////////////////////////////////////////////////
    // var max_value_ME      = 5.0 ; /////////////////////////////////////////////////
    // var min_max_array_ME  = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5]  ; /////////////////////////////////////////////////
    //
    // var min_value_dpt     = 0.0 ; /////////////////////////////////////////////////
    // var max_value_dpt     = 5.0 ; /////////////////////////////////////////////////
    // var min_max_array_dpt = [0, 0.1, 0.2, 0.3, 0.4, 0.5, 2, 3.5, 5]  ; /////////////////////////////////////////////////


    var dft_opacity       = 0.4;
    var dft_weight        = 0.5;
    var dft_rivers_weight = 0.2;
    var dft_null_color    = "#f0f0f0" ;
    var dft_stroke_color  = "white"   ;
    var dft_rivers_color  = "#081d58" ;
    var z_index_dft       = 3 ;



    // choose between  - sequential / divergent / qualitative - colorscales
    function chooseColorScale( seq_div_qual ) {

      if ( seq_div_qual == "sequential" ) {
        var colorScale  = chroma
          .scale( {{ choropleths.seq_beige_blue_red|safe }} )
          .domain( [ 0.0001, scale_limitUp ], 9, 'log' );
      }
      else if ( seq_div_qual == "counts") {
        var colorScale  = chroma
          .scale( {{ choropleths.seq_yel_red|safe }} )
          .domain( [ 0.0, scale_limitUp_count ], 9 );
      }
      else if ( seq_div_qual == "divergent") {
        var colorScale  = chroma
          .scale( {{ choropleths.div_gre_yel_red|safe }} )
          .domain( [ -3.0, 3.0 ], 11 );
      }
      else if (seq_div_qual == "qualitative") {
        var colorScale  = chroma
          .scale( {{ choropleths.qual_12_hard|safe }} )
          .domain( [ 0, 12 ] );
      }
      ;

      return colorScale ;
    };

    function chooseMinMaxArray( seq_div_qual ) {
      if ( seq_div_qual == "sequential" ){
        var min_max_array = min_max_array_concent ;
      }
      else if ( seq_div_qual == "counts" ){
        var min_max_array = min_max_array_count ;
      }
      else if ( seq_div_qual == "divergent" ){
        var min_max_array = min_max_array_diverg ;
      }
      else if ( seq_div_qual == "qualitative" ){
        var min_max_array = min_max_array_count ;
      };

      return min_max_array;
    };

    // function chooseMinMaxArray( req_df ) {
    //   if ( selected_layer == df_ME ){
    //     var min_max_array = min_max_array_ME ;
    //   }
    //   else if ( selected_layer == df_dpt ){
    //     var min_max_array = min_max_array_dpt ;
    //   };
    //   return min_max_array;
    // };

    // CREATE LEGEND
    var legend ; // global empty variable
    var selected_layer = df_ME ;
    //var scale_categ    = "sequential" ;
    //var categ          = "MOYPTOT"    ;


    // create legend control
    function createLegend( seq_div_qual ) {

      var colorScale    = chooseColorScale(  seq_div_qual );
      var min_max_array = chooseMinMaxArray( seq_div_qual );
      // var min_max_array = chooseMinMaxArray( selected_layer );

      console.log("createLegend / selected_layer :", selected_layer );

      legend = L.control({position: 'bottomright'});

      legend.onAdd = function (map) {

          var div = L.DomUtil.create('div', 'info legend');
          var grades = min_max_array  ;

          if (seq_div_qual == "sequential")  { var label = "moyenne des concentrations totales " + "(" + year + ")", unit = "ug/l" ; }
          else if (seq_div_qual == "counts") { var label = "nombre de pesticides détectés / " + pest_map + " : " + dict_categs_legend[index_map][pest_map] + " (" + year + ")", unit = "pest." ; };

          div.innerHTML += '<p>' + label + '</p>';

          // loop through our density intervals and generate a label with a colored square for each interval
          // first loop for colored legend boxes
          for (var i = 0; i < grades.length; i++) {
              div.innerHTML +=
                  '<span style="background:' + colorScale(grades[i]) + '; opacity:' + dft_opacity + '"></span> ';
          }
          // a line break
          div.innerHTML += '<br>';

          // second loop for text
          for (var i = 0; i < grades.length; i++) {
              div.innerHTML +=
                  '<label>' + (grades[i + 1] ? '<' + grades[i]  : '>=' + grades[i] ) + '</label>';
          }
          div.innerHTML += '<label>' + unit + '</label>';

          return div;
      };

      legend.addTo(map);

    };


    // VIZUALISATION OF DATA ON LAYERS
    function handleLayer(layer, value_fill, req_df, seq_div_qual, z_index ){


      // layer.setZIndex(10); // not working (just works on Tiles)


      var stroke_color  = dft_stroke_color ;
      var stroke_weight = dft_weight ;

      // ignore null values when coloring
      if (value_fill != null ){

        //fillOpacity = ( dft_opacity * value_fill / max_value ) + 0.1 ;
        fillOpacity = dft_opacity  ;

        var colorScale = chooseColorScale( seq_div_qual );
        var fillColor  = colorScale(value_fill).hex();

      }

      else { /// <-- rivers for now
        var fillColor   = dft_null_color ;
        var fillOpacity = 0 ;
        stroke_color    = dft_rivers_color  ;
        stroke_weight   = dft_rivers_weight ;
      }

      //layer.bindpopup()
      layer.setStyle({
        fillColor  : fillColor,
        fillOpacity: fillOpacity,
        color      : stroke_color,
        weight     : stroke_weight,
        opacity    : 1
      });

      if (req_df != df_rivers ) {
        layer.on({
          mouseover: enterLayer,
          mouseout : leaveLayer,
          click    : zoomToFeature
        });
      };
    };

    function enterLayer(e){
      //this.bringToFront();
      this.setStyle({
        weight : dft_weight + 3,
        opacity: 1
      });

    //   div_tooltip_map.transition()
    //       .duration(200)
    //       .style("opacity", .9);
    //   div_tooltip_map.html(" test : " + e.target.feature.properties.NomMasseDE + "<br>" )
    //       .style("left", (d3.event.pageX - 30) + "px")
    //       .style("top",  (d3.event.pageY - 30) + "px")
    };

    function leaveLayer(e){
      //this.bringToBack();
      this.setStyle({
        weight : dft_weight,
        opacity: dft_opacity
      });

      // div_tooltip_map.transition()
      //     .duration(500)
      //     .style("opacity", 0);
      // div_tooltip_map.html("")
      //     .style("left", "0px")
      //     .style("top",  "0px");

      // rivers_layer.eachLayer( function(layer) {
      //   layer.bringToBack()
      //});
    };

    function zoomToFeature(e) {

      //map.fitBounds(e.target.getBounds());

      var props = e.target.feature.properties ;
      //console.log(props);
      //toggleSidebarInfos();
      displayInfos(props);
    };

    // display infos on click
    var toggledLast ;

    var root_ME_SANDRE = "http://www.sandre.eaufrance.fr/fiche-geo?id=rdytcq/dataset/244/MasseDEauSouterraine/" ;

    var ME_infos_dict = {
      "Karstique" : { "def"     : "Le caractère karstique est attribué aux masses d’eau souterraine qui comportent des karsts actifs, fonctionnels (fonctionnement hydraulique particulier avec une organisation spécifique du drainage). Les masses d’eau de ce type sont caractérisées par la présence de zones de surface d’une extrême vulnérabilité et des écoulements souterrains particulièrement rapides",
                      "def_val" : {"N": "non", "Y" : "oui"},
                      "link"    : "http://www.sandre.eaufrance.fr/squelettes/consulter_fiche_attribut.php?dictionnaire=/db/sandre/Schemas/mdo/1.2/sandre_fmt_xml_mdo.xsd&entite=MasseDEauSouterraine&attribut=Karstique",
                    },
      "Niveau"    : { "def"     : "Dans le cas où 2 ou plusieurs masses d'eau souterraine sont superposées, l'attribut niveau permet de positionner les masses d'eau les une par rapport aux autres pour le polygone élémentaire concerné. La masse d'eau la plus profonde ayant le niveau le plus élevé. Le niveau commence à 1",
                      "def_val" : { "0" : "",
                                    "1" : "",
                                    "2" : ""
                                  },
                      "link"    : "",
                    },
      "FrangeLitt" : {"def"     : "Les masses d’eau côtières et insulaires en relation avec l’eau de mer peuvent, en raison d’une surexploitation chronique ou temporaire (forte augmentation estivale des captages AEP), induire un risque d’intrusion saline des aquifères",
                      "def_val" : {"N": "non", "Y" : "oui"},
                      "link"    : "http://www.sandre.eaufrance.fr/squelettes/consulter_fiche_attribut.php?dictionnaire=/db/sandre/Schemas/mdo/1.2/sandre_fmt_xml_mdo.xsd&entite=MasseDEauSouterraine&attribut=FrangeLittorale",
                    },
      "TypeMasseD" : {"def"     : "Les classes de masse d’eau souterraine sont définies par l’arrêté du 12 janvier 2010 (publié au JORF n.0027 du 2 février 2010) relatif aux méthodes et aux critères à mettre en œuvre pour délimiter et classer les masses d'eau et dresser l'état des lieux prévu à l'article R. 212-3 du code de l'environnement.",
                      "def_val" : { "A"  : "Alluvial",
                                    "DS" : "Dominante sédimentaire non alluviale",
                                    "EV" : "Edifice volcanique",
                                    "IP" : "Système hydraulique composite propre aux zones intensément plissées de montagne",
                                    "S"  : "Socle",
                                    "IL" : "Imperméable localement"
                                  },
                      "link"    : "http://www.sandre.eaufrance.fr/squelettes/consulter_fiche_attribut.php?dictionnaire=/db/sandre/Schemas/mdo/1.2/sandre_fmt_xml_mdo.xsd&entite=MasseDEauSouterraine&attribut=TypeMasseDEauSouterraine",
                    },
      "NatureEcou" : {"def"     : "La nature des écoulements d’une masse d’eau souterraine est définie par l’arrêté du 12 janvier 2010 (publié au JORF n.0027 du 2 février 2010) relatif aux méthodes et aux critères à mettre en œuvre pour délimiter et classer les masses d'eau et dresser l'état des lieux prévu à l'article R. 212-3 du code de l'environnement.",
                      "def_val" : { "0" : "Inconnu",
                                    "1" : "Entièrement libre",
                                    "2" : "Entièrement captif",
                                    "3" : "Une ou des partie(s) libre(s) et une ou des partie(s) captive(s), les écoulements sont majoritairement libres",
                                    "4" : "Une ou des partie(s) libre(s) et une ou des partie(s) captive(s), les écoulements sont majoritairement captifs",
                                  },
                      "link"    : "http://www.sandre.eaufrance.fr/squelettes/consulter_fiche_attribut.php?dictionnaire=/db/sandre/Schemas/mdo/1.2/sandre_fmt_xml_mdo.xsd&entite=MasseDEauSouterraine&attribut=NatureEcoulement",
                    },
    };

    function displayInfos(props) {

      // close sidebar
      if (toggledLast == props | toggled == -1 ) {

        //$("#collapseInfosNappe").collapse('hide');
        $("#collapseInfosPest").collapse('hide');

        toggleSidebarInfos();

      }

      // do nothing on sidebar and display infos
      else {

        toggledLast = props ;

        //console.log(props);

        d3.select('#sb_title').html( props.NomMasseDE ); //+ " (" + props.CdMasseDEa + ")");

        d3.select('#reqTree_ME').attr("reqvalue", props.CdMasseDEa);

        d3.select('#CdMasseDEa').html( props.CdMasseDEa )
                                .attr( "href", root_ME_SANDRE + props.CdMasseDEa );

        // d3.select('#NomMasseDE').html(props.NomMasseDE);

        d3.select('#Niveau_').attr( "title", ME_infos_dict["Niveau"]["def"] );
        d3.select('#Niveau').html(  props.Niveau );
        d3.select('#TypeMasseD_').attr( "title", ME_infos_dict["TypeMasseD"]["def"] );
        d3.select('#TypeMasseD').html( ME_infos_dict["TypeMasseD"]["def_val"][props.TypeMasseD] )
                                .attr( "href", ME_infos_dict["TypeMasseD"]["link"] );
        // d3.select('#TypeMasseD').html( props.TypeMasseD );
        d3.select('#Karstique_').attr( "title", ME_infos_dict["Karstique"]["def"] );
        d3.select('#Karstique').html(  ME_infos_dict["Karstique"]["def_val"][props.Karstique] )
                                .attr( "href", ME_infos_dict["Karstique"]["link"] );
        // d3.select('#Karstique').html(  props.Karstique );
        d3.select('#FrangeLitt_').attr( "title", ME_infos_dict["FrangeLitt"]["def"] );
        d3.select('#FrangeLitt').html( ME_infos_dict["FrangeLitt"]["def_val"][props.FrangeLitt] )
                                .attr( "href", ME_infos_dict["FrangeLitt"]["link"] );
        // d3.select('#FrangeLitt').html( props.FrangeLitt );
        d3.select('#NatureEcou_').attr( "title", ME_infos_dict["NatureEcou"]["def"] );
        d3.select('#NatureEcou').html( ME_infos_dict["NatureEcou"]["def_val"][props.NatureEcou] )
                                .attr( "href", ME_infos_dict["NatureEcou"]["link"] );

        // d3.select('#NatureEcou').html( props.NatureEcou );

        d3.select('#FONCTIONS').html( props.FUNCTIONS );

        $("#collapseInfosNappe").collapse('show');

      }

    };

    // refresh min-max values
    // function refreshMinMax_MOYPTOT ( req_df_, data_minmax ) {
    //
    //   new_min    = data_minmax.min ;
    //   new_max    = data_minmax.max ;
    //   new_minmax = data_minmax.min_max_array ;
    //
    //   // update min_max arrays
    //   if ( req_df_ == df_ME ){
    //     min_max_array_ME = new_minmax ;
    //     max_value_ME     = new_max ;
    //     min_value_ME     = new_min ;
    //   }
    //   else if ( req_df_ == df_dpt ){
    //     min_max_array_dpt = new_minmax ;
    //     max_value_dpt     = new_max ;
    //     min_value_dpt     = new_min ;
    //   } ;
    //
    //   console.log("refreshMinMax_MOYPTOT / new_minmax :", new_minmax );
    //
    // };


    // refresh legend scale
    function refreshLegend ( req_df_, seq_div_qual ) {

      console.log("refreshLegend " );
      //console.log("refreshLegend / legend :", legend );

      // new_min    = data_minmax.min ;
      // new_max    = data_minmax.max ;
      // new_minmax = data_minmax.min_max_array ;
      //
      // // update min_max arrays
      // if ( req_df_ == df_ME ){
      //   min_max_array_ME = new_minmax ;
      //   max_value_ME     = new_max ;
      //   min_value_ME     = new_min ;
      // }
      // else if ( req_df_ == df_dpt ){
      //   min_max_array_dpt = new_minmax ;
      //   max_value_dpt     = new_max ;
      //   min_value_dpt     = new_min ;
      // } ;
      //
      // console.log("refreshLegend / new_minmax :", new_minmax );

      // refresh legend only if it corresponds to selected layer
      if ( req_df_ == selected_layer ){

        // remove previous legend if already exists
        if (legend != undefined) {
          legend.remove();
          //console.log("refreshLegend / legend.remove() ");
        };

        // recreate a legend choosing between sequential / divergent / qualitative
        createLegend( seq_div_qual ) ;

      };
    };

    // update layer data
    function refreshTopoLayer ( req_df, dataset ) {

      if ( req_df == df_ME )       { topoLayer = topoLayer_water; }
      else if ( req_df == df_dpt ) { topoLayer = topoLayer_admin; }
      else                         { topoLayer = topoLayer_rivers; };

      console.log("refreshTopoLayer / start for req_df :", req_df );

      topoLayer.eachLayer(

        function(layer) {

          if (req_df == df_ME) {
            var index_geom = layer.feature.properties.CdMasseDEa ;
            //console.log(" io_slice_from_server / index_ME : ", index_ME)
          } else if (req_df == df_dpt) {
            var index_geom = layer.feature.properties.code ;
          } else {
            var index_geom = null ;
          };

          var data_L_MOYPTOT         = dataset["MOYPTOT"][ index_geom ] ;
          //var data_L_MOYPTOT_all_CAS = _.pickBy(dataset["MOYPTOT_all_CAS"][ index_geom ]) ; // using LoDash to skip null values
          //var data_L_MOYPTOT_all_CAS = _.omitBy(dataset["MOYPTOT_all_CAS"][ index_geom ], _.isNil ) ; // using LoDash to skip null values
          var data_L_FUNCTIONS       = dataset["FUNCTIONS"][ index_geom ] ;
          var data_L_FAMILLES        = dataset["FAMILLES"][ index_geom ] ;
          var data_L_TYPES           = dataset["TYPES"][ index_geom ] ;

          layer.feature.properties.MOYPTOT         = data_L_MOYPTOT ;
          //layer.feature.properties.MOYPTOT_all_CAS = data_L_MOYPTOT_all_CAS ;
          layer.feature.properties.FUNCTIONS       = data_L_FUNCTIONS ;
          layer.feature.properties.FAMILLES        = data_L_FAMILLES ;
          layer.feature.properties.TYPES           = data_L_TYPES ;

        }
      );
    };

    // refresh map : colors and scale
    function refreshMap ( req_df, index_map, req_query, seq_div_qual ) {

      console.log("refreshMap / start for req_df :", req_df );

      // choose topolayer
      if ( req_df == df_ME  )      {
        topoLayer = topoLayer_water;
        // sort layers by Niveau --> draw higher (deeper) first
        console.log("refreshMap / sort topoLayer...");
        //
        console.log( topoLayer );
      }
      else if ( req_df == df_dpt ) { topoLayer = topoLayer_admin; }
      else                         { topoLayer = topoLayer_rivers; };

      // iterate and update map
      topoLayer.eachLayer(

        function(layer) {


          if      (index_map == "MOYPTOT")         { value_ = layer.feature.properties.MOYPTOT   }
          //if      (index_map == "MOYPTOT_all_CAS") { value_ = layer.feature.properties.MOYPTOT_all_CAS  }
          else if (index_map == "FUNCTIONS")       { value_ = layer.feature.properties.FUNCTIONS }
          else if (index_map == "FAMILLES")        { value_ = layer.feature.properties.FAMILLES  }
          else if (index_map == "TYPES")           { value_ = layer.feature.properties.TYPES     } ;

          // handle missing data
          //console.log( layer.feature.properties.CdMasseDEa , value_);

          if (value_ != null ){
            if ( req_query in value_ ) {
              value_fill = value_[ req_query ]
            }
            else {
              value_fill = null
            }
          } else {
            value_fill = null
          };

          //console.log( value_[ req_query ]);
          //console.log( value_fill );

          //console.log("refreshMap / value_fill :", value_fill );

          // set z_index of current layer if
          var z_index = z_index_dft;



          handleLayer( layer, value_fill , req_df, seq_div_qual, z_index );

        });

    };

    // var queue = d3_queue.queue(1);
    // queue
    //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.water ) }}" ) // topojson water
    //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.admin ) }}" ) // topojson admin
    //   .awaitAll(InitMap_) ;

    //// InitMap as callback function --> first to run then (callback)

    //function InitMap () {
    //InitMap = function (callback) {
    function InitMap (callback) {

      //var def = new $.Deferred();

      // GET TOPOJSON FILES
      $.getJSON( "{{ url_for ( 'static', filename = basemaps.ME ) }}" )
        .done(addTopoData_ME);
      $.getJSON( "{{ url_for( 'static', filename  = basemaps.admin ) }}" )
         .done(addTopoData_admin);
      $.getJSON( "{{ url_for( 'static', filename  = basemaps.rivers ) }}" )
        .done(addTopoData_rivers);

      //load main cities /////////////////////////////////////////////
      // $.getJSON( "{{ url_for( 'static', filename  = basemaps.cities ) }}" )
      //   .done(addGeoDataCities);

      // LOAD CITIES DATAS
      function addGeoDataCities(geooData){
        console.log(" - leaflet -- starting / addGeoDataCities ");
        console.log(" - leaflet -- addGeoDataCities / datas : ", geooData);
        geoLayer_cities.addData(geooData);
        geoLayer_cities.addTo(cities_layer);

        geoLayer_cities.eachLayer(
          function (layer) {
            //handleLayer(layer, null , df_rivers);
            layer.bringToFront();
          });

        console.log(" - leaflet -- finished / addGeoDataCities ");

      };

      // PROCESS TOPOJSON // WARNING : OVERWRITES previous TOPOLAYER object
      function addTopoData_ME(topoData){
        console.log(" - leaflet -- starting / addTopoData_ME ");
        topoLayer_water.addData(topoData);
        topoLayer_water.addTo(ME_layer);
        console.log(" - leaflet -- finished / addTopoData_ME ");

        callback(); // <-- callback inside last called function
      };

      function addTopoData_admin(topoData){
        console.log(" - leaflet -- starting / addTopoData_admin ");
        topoLayer_admin.addData(topoData);
        topoLayer_admin.addTo(admin_layer);
        console.log(" - leaflet -- finished / addTopoData_admin ");
      };

      function addTopoData_rivers(topoData){
        console.log(" - leaflet -- starting / addTopoData_rivers ");
        topoLayer_rivers.addData(topoData);
        topoLayer_rivers.addTo(rivers_layer);

        //topoLayer_rivers.eachLayer(handleLayer); /////////////////////////////////////
        topoLayer_rivers.eachLayer(
          function (layer) {
            handleLayer(layer, null , df_rivers, z_index_dft);
            layer.bringToBack();
          }
        );

        console.log(" - leaflet -- finished / addTopoData_rivers ");
        console.log("");

      };

      // modify Leaflet controls
      $(".leaflet-control-layers").addClass("leaflet-control-layers-expanded") ;

      //return def.promise();

    }; // <-- end : InitMap


    // START ConnectSocketIO = function () {
    function ConnectSocketIO () {


      // INITIATE SOCKET IO CONNECTION
      var socket = io.connect('http://' + document.domain + ':' + location.port);

      // EMIT REQUEST SLICE TO SERVER
      function EmitRequestSlice(df_name) {
        socket.emit(
          'io_request_slice', {
            msg                 : req_client ,
            df_source           : df_name ,
            slice_query_index   : [ year, pest_map ] ,
            slice_query_columns : [ ]
          }
        );
      };

      // EMIT REQUEST TREE TO SERVER
      function EmitRequestTree(df_name, area ) {
        socket.emit(
          'io_request_tree', {
            msg                 : req_client ,
            df_source           : df_name ,
            slice_query_index   : [ year, pest_map ] ,
            slice_query_columns : area
          }
        );
      };

      // INITIATE MAP DATAS ON CONNECTION
      socket.on('connect', function() {
        // socket.emit('connection start', {data: '--> client connected from : ' + document.domain + ':' + location.port });

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        //EmitRequestTree(df_ME, index_geom );

      });

      // IO - REFRESH DATAS AND MAP WHEN RECEIVING NEW DATA
      socket.on('io_slice_from_server', function( data_slice ) {

        //var req_query            = pest ; //data_slice.request_query   ; // "XXXXXX" for instance

        console.log(" *** io_slice_from_server / data_slice (raw) : "  ) //, " - req_query : ", req_query ) ;
        //console.log(data_slice);

        var data_MOYPTOT         = data_slice.slice_MOYPTOT.data    ;
        //var data_MOYPTOT_minmax  = data_slice.slice_MOYPTOT.min_max ;

        //var data_MOYPTOT_all_CAS = data_slice.slice_MOYPTOT_all_CAS.data    ;

        var data_FUNCTIONS       = data_slice.slice_FUNCTIONS.data ;
        var data_FAMILLES        = data_slice.slice_FAMILLES.data  ;
        var data_TYPES           = data_slice.slice_TYPES.data     ;

        //var seq_div_qual         = data_slice.seq_div_qual    ;
        var req                  = data_slice.request_sent    ;
        var req_df_              = req.df_source              ;

        //console.log(" io_slice_from_server / req : ", req) ;
        console.log(" *** io_slice_from_server / req_df_ : "    , req_df_ ) //, " - req_query : ", req_query ) ;
        //console.log(" io_slice_from_server / data_minmax : ", data_MOYPTOT_minmax) ;



        // parse data from JSON
        var data_MOYPTOT_json         = JSON.parse(data_MOYPTOT) ;
        //var data_MOYPTOT_all_CAS_json = JSON.parse(data_MOYPTOT_all_CAS) ;
        var data_FUNCTIONS_json       = JSON.parse(data_FUNCTIONS) ;
        var data_FAMILLES_json        = JSON.parse(data_FAMILLES) ;
        var data_TYPES_json           = JSON.parse(data_TYPES) ;

        var dataset = {
          "MOYPTOT"         : data_MOYPTOT_json,
          //"MOYPTOT_all_CAS" : data_MOYPTOT_all_CAS_json,
          "FUNCTIONS"       : data_FUNCTIONS_json,
          "FAMILLES"        : data_FAMILLES_json,
          "TYPES"           : data_TYPES_json
        };

        // set global vars for TOT_FRANCE for treemap
        //var MOYPTOT_FR   = data_MOYPTOT_json["TOT_FRANCE"] ;
        var FUNCTIONS_FR = data_FUNCTIONS_json["TOT_FRANCE"] ;
        var FAMILLES_FR  = data_FAMILLES_json["TOT_FRANCE"] ;
        var TYPES_FR     = data_TYPES_json["TOT_FRANCE"] ;


        // refresh in ordrer : MINMAX -> LEGEND -> TOPOLAYER --> MAP
        //refreshMinMax_MOYPTOT ( req_df_, data_MOYPTOT_minmax ) ;
        refreshLegend(          req_df_, categ_map ) ;
        refreshTopoLayer(       req_df_, dataset );
        // refreshMap (            req_df_, "MOYPTOT_all_CAS", req_query, seq_div_qual );
        refreshMap (            req_df_, index_map, pest_map, categ_map );

        console.log("");

      }); // <-- end : io_slice_from_server


      // IO - REFRESH DATAS AND TREEMAP WHEN RECEIVING NEW DATA
      socket.on('io_tree_from_server', function ( tree_pests ) {

        // console.log( " *** io_tree_from_server", tree_pests );

        var tree_FAMILLES  = JSON.parse(tree_pests.tree_FAMILLES) ;
        var tree_FUNCTIONS = JSON.parse(tree_pests.tree_FUNCTIONS) ;
        var tree_TYPES     = JSON.parse(tree_pests.tree_TYPES) ;

        console.log( " *** io_tree_from_server / tree_FAMILLES" );
        //console.log(tree_FAMILLES);

        dataset_trees = {
          "byFamilies"  : tree_FAMILLES,
          "byFunctions" : tree_FUNCTIONS,
          "byTypes"     : tree_TYPES,
        };

        // makeTreeMap (tree_FUNCTIONS);
        d3.select('#pest_proportions').html(index_geom); // + " (en " + year + ")");
        makeTreeMap ( dataset_trees, radio_tree );

      }); // <-- end : io_tree_from_server


      $(".switchCategTree").on("click", function() {

        categ_tree = $(this).attr("value") ;

        console.log("switchCategTree / categ_tree : " , categ_tree) ;

        radio_tree = categ_tree ;
        makeTreeMap ( dataset_trees, radio_tree )

      });


      // REQUEST BUTTONS
      $('.request').on('click', function() {

        var req_value = $(this).attr("reqvalue");
        var req_type  = $(this).attr("reqtype") ;

        //console.log( "req_type : " + req_type + " / " + req_value + " (" + jQuery.type(req_value) + ")" );

        if ( req_type == "year") {
          year = req_value ;
        }

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        EmitRequestTree(df_ME, index_geom );

      });


      // SLIDER YEARS
      $(".slider_years").on("input change", function() {

        //console.log(this) ;

        var year_slide = this.value ;

        console.log("slider_years / year : ", year_slide) ;

        document.querySelector('#annee_selected').value = year_slide ;
        document.querySelector('#annee_selected2').value = year_slide ;

        var req_value = year_slide ;
        var req_type  = "year";

        // console.log( "req_type : " + req_type + " / " + req_value + " (" + jQuery.type(req_value) + ")" );
        if ( req_type == "year") {
          year = req_value ;
        }

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

        EmitRequestTree(df_ME, index_geom);

        $(".slider_years").val(year_slide) ;
        //$(".slider_years").slider('refreh') ;

      });


      // BUTTONS FOR COUNTS : FUNCTIONS / FAMILLES / TYPES
      $(".switchmap").on("click", function() {

        //console.log(this) ;

        var req_value = $(this).attr("reqvalue"); // ex.
        var req_type  = $(this).attr("reqtype") ; // ex.

        if ( req_type == "MOYPTOT" ) { categ_map = "sequential" }
        else                         { categ_map = "counts" };

        var req_df_ = df_ME   ; /////////

        index_map = req_type  ;
        pest_map  = req_value ;

        console.log("switchmap / req_value : ", req_value , " / req_type : ", req_type) ;

        refreshLegend( req_df_, categ_map ) ;
        refreshMap (   req_df_, index_map, pest_map, categ_map );

        console.log("");

      });


      // UPDATE TREEMAP
      $(".switchtree").on("click", function() {

        //console.log(this) ;

        var req_value = $(this).attr("reqvalue"); // ex.

        index_geom = req_value;
        area       = req_value ;

        console.log("switchtree / req_value : ", req_value ) ;

        EmitRequestTree( df_ME, area )

      });

    }; // <-- end : ConnectSocketIO


  $(document).ready(function() { // <-- place at top to run stuff in order


    $('#mod_intro').modal('toggle');

    //InitMap().then(ConnectSocketIO); // <-- with defer
    //ConnectSocketIO();
    InitMap( ConnectSocketIO ); // <-- with callback

    console.log(" - InitMap / finished ");
    console.log(" ");



  }); //<-- end : $(document).ready



}); // <-- end : $(window).load


</script>
