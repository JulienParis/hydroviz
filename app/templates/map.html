
<style>

  /* MAP CSS */
  #content {
    padding-left: 0px;
    padding-right: 0px;
  }
  html,body,#map{
    /*height : 90%;*/
    width  : 100%;
    z-index: 1;
  }

  div .leaflet-control-container .leaflet-top {
    top: 20px;
  }


  div .leaflet-control-zoom {
    display: inline-flex;

  }
  div .leaflet-bar a:first-child {
    border-top-right-radius: 0px;
    border-top-left-radius: 4px;
    border-bottom-right-radius: 0px;
    border-bottom-left-radius: 4px;
    border-bottom : none;
    border-right : 1px solid #ccc ;
  }
  div .leaflet-bar a:last-child {
    border-top-right-radius: 4px;
    border-top-left-radius: 0px;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 0px;
  }


  .info {
      padding: 6px 8px;
      font: 14px/16px Arial, Helvetica, sans-serif;
      background: white;
      background: rgba(255,255,255,0.8);
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 5px;
  }
  .info h4 {
      margin: 0 0 5px;
      color: #777;
  }

  .legend span, .legend label {
  display: block;
  width: 50px;
  height: 18px;
  float: left;
  opacity: 0.7;
  text-align: center;
  font-size: 80%
  }

</style>


<div id="map" style="position: fixed;"></div>

<!-- CHROMA JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/chroma-js/0.5.9/chroma.min.js"></script>

<!-- MARKER CLUSTER -->
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.Default.css" />
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.css" />
<script type='text/javascript' src='https://unpkg.com/leaflet.markercluster@1.0.0/dist/leaflet.markercluster.js'></script>


<script>

  // CHECK WINDOW SIZE
  $(window).load(function() {

    var window_w = window.innerWidth;
    var window_h = window.innerHeight;
    var navbar_h = $('header').outerHeight();
    var map_h    = window_h - navbar_h ;
    console.log( "window_w : ", window_w," - window_h : ", window_h, " - navbar_h : ", navbar_h );
    // return desired height to map
    $('#map').css({"height": map_h});

    // CREATE EMPTY LAYERS GROUPS
    var ME_layer     = new L.layerGroup();
    var rivers_layer = new L.layerGroup();
    var admin_layer  = new L.layerGroup();

    //var stations_layer = new L.layerGroup();
    var stations_layer_cluster = L.markerClusterGroup({
        spiderfyOnMaxZoom: false,
        showCoverageOnHover: false,
        zoomToBoundsOnClick: true
    });

    // BASEMAP TILES
    var mbAttr =
      'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
      '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
      'Imagery <a href="http://mapbox.com">Mapbox</a>';
    var mbUrl  = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw';

    var grayscale  = L.tileLayer(mbUrl, {id: 'mapbox.light'  , attribution: mbAttr});
    var streets    = L.tileLayer(mbUrl, {id: 'mapbox.streets', attribution: mbAttr});

    // LEAFLET MAP OBJECT
    var map = L.map('map', {
      center     : [47, 3],
      zoom       : 6,
      layers     : [ grayscale, ME_layer, rivers_layer ], // active layers
      zoomControl:false
    });

    // CREATE CONTROLS
    var baseLayers = {
      "Fond gris": grayscale,
      "Fond OSM" : streets
    };

    var overlays = {
      "nappes phréatiques" : ME_layer,
      "départements"       : admin_layer,
      "stations de mesure" : stations_layer_cluster,
      "eaux de surface"    : rivers_layer,
    };

    var zoom     = L.control.zoom( { position : "topright"} ).addTo(map);
    var controls = L.control.layers(
      baseLayers, overlays,
      { position : "topright" }
    ).addTo(map);


    // TOPOJSON HANDLING - TOPOJSON OBJECTS FOR LEAFLET
    L.TopoJSON = L.GeoJSON.extend({
      addData: function(jsonData) {
        if (jsonData.type === "Topology") {
          for (key in jsonData.objects) {
            geojson = topojson.feature(jsonData, jsonData.objects[key]);
            L.GeoJSON.prototype.addData.call(this, geojson);
          }
        }
        else {
          L.GeoJSON.prototype.addData.call(this, jsonData);
        }
      }
    }); // Copyright (c) 2013 Ryan Clark

    // CREATE EMPTY TOPOJSON-LEAFLET OBJECTS
    var topoLayer_water    = new L.TopoJSON();
    var topoLayer_rivers   = new L.TopoJSON();
    var topoLayer_admin    = new L.TopoJSON();
    var topoLayer_stations = new L.TopoJSON();

    // CREATE GRADIENTS --> CHECK VARIATIONS FROM COLORBREWER

    var min_value  = 0.0 ; /////////////////////////////////////////////////
    var max_value  = 0.5 ; /////////////////////////////////////////////////
    var min_max_array = [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5] ; /////////////////////////////////////////////////

    var colorScale_water = chroma
      .scale( {{ choropleths.seq_turquoise|safe }} )
      .domain([min_value, max_value ]);
    var colorScale_admin = chroma
      .scale( {{ choropleths.seq_turquoise|safe }} )
      .domain([min_value, max_value ]);

    // CREATE LEGEND
    var legend = L.control({position: 'bottomright'});

    legend.onAdd = function (map) {

        var div = L.DomUtil.create('div', 'info legend'),
            grades = min_max_array,
            labels = [];

        div.innerHTML += '<div> concentrations </p>';

        // loop through our density intervals and generate a label with a colored square for each interval
        // first loop for colored legend boxes
        for (var i = 0; i < grades.length; i++) {
            div.innerHTML +=
                '<span style="background:' + colorScale_water(grades[i]) + '"></span> ';
        }
        // a line break
        div.innerHTML += '<br>';

        // second loop for text
        for (var i = 0; i < grades.length; i++) {
            div.innerHTML +=
                '<label>' + grades[i] + (grades[i + 1] ? '&ndash;' + grades[i + 1] : '+') + '</label>';
        }
        return div;
    };

    legend.addTo(map);


    var dft_opacity       = 0.55;
    var dft_weight        = 0.5;
    var dft_rivers_weight = 0.2;
    var dft_null_color    = "#f0f0f0";
    var dft_stroke_color  = "white";
    var dft_rivers_color  = "#081d58" ;

    // VIZUALISATION OF DATA ON LAYERS
    function handleLayer(layer, value_fill, layer_name ){

      var stroke_color  = dft_stroke_color ;
      var stroke_weight = dft_weight ;

      // ignore null values when coloring
      if (value_fill != null ){

        //fillOpacity = ( dft_opacity * value_fill / max_value ) + 0.1 ;
        fillOpacity = dft_opacity  ;

        if ( layer_name == df_ME ) {
          var fillColor = colorScale_water(value_fill).hex();
        } else if (layer_name == df_dpt ) {
          var fillColor = colorScale_admin(value_fill).hex();
        }
      }

      else { /// <-- rivers for now
        var fillColor   = dft_null_color ;
        var fillOpacity = 0 ;
        stroke_color    = dft_rivers_color  ;
        stroke_weight   = dft_rivers_weight ;
      }

      layer.setStyle({
        fillColor  : fillColor,
        fillOpacity: fillOpacity,
        color      : stroke_color,
        weight     : stroke_weight,
        opacity    : 1
      });

      if (layer_name != df_rivers ) {
        layer.on({
          mouseover: enterLayer,
          mouseout : leaveLayer,
          click    : zoomToFeature
        });
      };
    };

    function enterLayer(){
      //this.bringToFront();
      this.setStyle({
        weight : dft_weight + 3,
        opacity: 1
      });
    };

    function leaveLayer(){
      //this.bringToBack();
      this.setStyle({
        weight : dft_weight,
        opacity: dft_opacity
      });
      // rivers_layer.eachLayer( function(layer) {
      //   layer.bringToBack()
      //});
    };

    function zoomToFeature(e) {
      console.log(e);
      map.fitBounds(e.target.getBounds());
    }




    // update layer data
    function refreshTopoLayer ( layer_name, req_query, data_json ) {

      /// for instance : layer_name == "water"
      if (layer_name == df_ME){
        topoLayer = topoLayer_water;
      } else if (layer_name == df_dpt) {
        topoLayer = topoLayer_admin;
      } else {
        topoLayer = topoLayer_rivers;
      }

      topoLayer.eachLayer(

        function(layer) {

          if (layer_name == df_ME) {
            var index_geom = layer.feature.properties.CdMasseDEa ;
            //console.log(" io_slice_from_server / index_ME : ", index_ME)
          } else if (layer_name == df_dpt) {
            var index_geom = layer.feature.properties.code ;
          } else {
            var index_geom = null ;
          }

          var data_geom = data_json[index_geom] ;
          //console.log(" io_slice_from_server / index_ME : " + index_ME + " / data_ME : ", data_ME) ;

          layer.feature.properties.value = data_geom ;

          if (data_geom != null ){
            if (data_geom[ req_query ] != null ) {
              value = data_geom[ req_query ]
            }
          } else {
            value = null
          }
          handleLayer(layer, value , layer_name);
        }
      );
    };


    // var queue = d3_queue.queue(1);
    // queue
    //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.water ) }}" ) // topojson water
    //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.admin ) }}" ) // topojson admin
    //   .awaitAll(InitMap_) ;



    //// InitMap as callback function --> first to run then (callback)

    function InitMap (callback) {
    //function InitMap () {
    //InitMap = function (callback) {

      //var def = new $.Deferred();

      // GET TOPOJSON FILES
      $.getJSON( "{{ url_for ( 'static', filename = basemaps.ME ) }}" )
        .done(addTopoData_ME);
      $.getJSON( "{{ url_for( 'static', filename  = basemaps.admin ) }}" )
         .done(addTopoData_admin);
      $.getJSON( "{{ url_for( 'static', filename  = basemaps.rivers ) }}" )
        .done(addTopoData_rivers);


      // PROCESS TOPOJSON // WARNING : OVERWRITES previous TOPOLAYER object
      function addTopoData_ME(topoData){
        console.log(" - leaflet -- starting / addTopoData_ME ");
        topoLayer_water.addData(topoData);
        topoLayer_water.addTo(ME_layer);
        console.log(" - leaflet -- finished / addTopoData_ME ");

        callback(); // <-- callback inside last called function
      };

      function addTopoData_admin(topoData){
        console.log(" - leaflet -- starting / addTopoData_admin ");
        topoLayer_admin.addData(topoData);
        topoLayer_admin.addTo(admin_layer);
        console.log(" - leaflet -- finished / addTopoData_admin ");
      };

      function addTopoData_rivers(topoData){
        console.log(" - leaflet -- starting / addTopoData_rivers ");
        topoLayer_rivers.addData(topoData);
        topoLayer_rivers.addTo(rivers_layer);

        //topoLayer_rivers.eachLayer(handleLayer); /////////////////////////////////////
        topoLayer_rivers.eachLayer(
          function (layer) {
            handleLayer(layer, null , df_rivers);
            layer.bringToBack();
          }
        );

        console.log(" - leaflet -- finished / addTopoData_rivers ");

      };

      // modify Leaflet controls
      $(".leaflet-control-layers").addClass("leaflet-control-layers-expanded") ;

      //return def.promise();

    }; // <-- end : InitMap


    var df_ME       = "df_AV_ME"    ;
    var df_dpt      = "df_AV_dpt"   ;
    var df_stations = "df_stations" ;
    var df_rivers   = "df_rivers"   ;

    //ConnectSocketIO = function () {
    function ConnectSocketIO () {

      // default values
      var req_client = "request IO from client";
      var year   = "2007"   ;
      var pest   = "XXXXXX" ;

      // INITIATE SOCKET IO CONNECTION
      var socket = io.connect('http://' + document.domain + ':' + location.port);

      function EmitRequestSlice(df_name) {
        socket.emit(
          'io_request_slice', {
            msg                 : req_client ,
            df_source           : df_name ,
            slice_query_index   : [ year, pest ] ,
            slice_query_columns : [ ]
          }
        );
      };



      socket.on('connect', function() {
        // socket.emit('connection start', {data: '--> client connected from : ' + document.domain + ':' + location.port });
        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);
      });

      socket.on('io_slice_from_server', function(data_slice) {

        var req_query  = data_slice.request_query ; // "2007_XXXXXX" for instance
        var req        = data_slice.request_sent  ;
        var data_      = data_slice.slice_df    ;
        var req_df     = req.df_source  ;

        console.log(" io_slice_from_server / req : ", req) ;
        console.log(" io_slice_from_server / req_df : ", req_df) ;

        var data_json = JSON.parse(data_) ;

        refreshTopoLayer ( req_df, req_query, data_json );

        // update layer data
        // topoLayer_water.eachLayer(
        //
        //   function(layer) { ///////////////////////////////////////////////////
        //
        //     var index_ME = layer.feature.properties.CdMasseDEa ;
        //     //console.log(" io_slice_from_server / index_ME : ", index_ME)
        //
        //     var data_ME = data_json[index_ME] ;
        //     //console.log(" io_slice_from_server / index_ME : " + index_ME + " / data_ME : ", data_ME) ;
        //
        //     layer.feature.properties.value = data_ME ;
        //
        //     if (data_ME != null ){
        //       if (data_ME[ req_query ] != null ) {
        //         value = data_ME[ req_query ]
        //       }
        //     } else {
        //       value = null
        //     }
        //     handleLayer(layer, value , "water");
        //   }
        // );

      }); // <-- end : io_slice_from_server

      $('.request').on('click', function() {

        var req_value = $(this).attr("reqvalue");
        var req_type  = $(this).attr("reqtype");

        console.log( "req_type : " + req_type + " / " + req_value + " (" + jQuery.type(req_value) + ")" );
        if ( req_type == "year") {
          year = req_value ;
        }

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

      });



      $("#slider_years").on("input change", function() {

        console.log(this) ;

        var year_slide = this.value ;

        console.log(year_slide) ;

        document.querySelector('#annee_selected').value = year_slide ;

        var req_value = year_slide ;
        var req_type  = "year";

        // console.log( "req_type : " + req_type + " / " + req_value + " (" + jQuery.type(req_value) + ")" );
        if ( req_type == "year") {
          year = req_value ;
        }

        EmitRequestSlice(df_ME);
        EmitRequestSlice(df_dpt);

      });

    }; // <-- end : ConnectSocketIO


  $(document).ready(function() { // <-- place at top to run stuff in order

    //InitMap().then(ConnectSocketIO); // <-- with defer
    InitMap( ConnectSocketIO ); // <-- with callback
    //ConnectSocketIO();

  }); //<-- end : $(document).ready



}); // <-- end : $(window).load

</script>
