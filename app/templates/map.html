
<style>

  /* MAP CSS */
  #content {
    padding-left: 0px;
    padding-right: 0px;
  }
  html,body,#map{
    height:100%;
    width: 100%;
    z-index: 1;
  }

  div .leaflet-control-container .leaflet-top {
    top: 20px;
  }


  div .leaflet-control-zoom {
    display: inline-flex;

  }
  div .leaflet-bar a:first-child {
    border-top-right-radius: 0px;
    border-top-left-radius: 4px;
    border-bottom-right-radius: 0px;
    border-bottom-left-radius: 4px;
    border-bottom : none;
    border-right : 1px solid #ccc ;
  }
  div .leaflet-bar a:last-child {
    border-top-right-radius: 4px;
    border-top-left-radius: 0px;
    border-bottom-right-radius: 4px;
    border-bottom-left-radius: 0px;
  }

</style>


<div id="map" style="position: fixed;"></div>

<!-- CHROMA JS -->
<script src="//cdnjs.cloudflare.com/ajax/libs/chroma-js/0.5.9/chroma.min.js"></script>

<!-- MARKER CLUSTER -->
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.Default.css" />
<link rel="stylesheet" type="text/css" href="https://unpkg.com/leaflet.markercluster@1.0.0/dist/MarkerCluster.css" />
<script type='text/javascript' src='https://unpkg.com/leaflet.markercluster@1.0.0/dist/leaflet.markercluster.js'></script>


<script>

  // CREATE EMPTY LAYERS GROUPS
  var water_layer    = new L.layerGroup();
  var admin_layer    = new L.layerGroup();

  //var stations_layer = new L.layerGroup();
  var stations_layer_cluster = L.markerClusterGroup({
      spiderfyOnMaxZoom: false,
      showCoverageOnHover: false,
      zoomToBoundsOnClick: true
  });

  // BASEMAP TILES
  var mbAttr =
    'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
    '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
    'Imagery <a href="http://mapbox.com">Mapbox</a>';
  var mbUrl  = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpandmbXliNDBjZWd2M2x6bDk3c2ZtOTkifQ._QA7i5Mpkd_m30IGElHziw';

  var grayscale  = L.tileLayer(mbUrl, {id: 'mapbox.light'  , attribution: mbAttr});
  var streets    = L.tileLayer(mbUrl, {id: 'mapbox.streets', attribution: mbAttr});

  // LEAFLET MAP OBJECT
  var map = L.map('map', {
    center: [47, 3],
    zoom: 6,
    layers: [ grayscale, water_layer ],
    zoomControl:false
  });

  // CREATE CONTROLS
  var baseLayers = {
    "Grayscale": grayscale,
    "Streets"  : streets
  };

  var overlays = {
    "water layer"    : water_layer,
    "admin layer"    : admin_layer,
    "stations layer" : stations_layer_cluster
  };

  var zoom = L.control.zoom( { position : "topright"} ).addTo(map);
  var controls = L.control.layers(baseLayers, overlays, { position:"topright" } ).addTo(map);

  // TOPOJSON HANDLING
  L.TopoJSON = L.GeoJSON.extend({
    addData: function(jsonData) {
      if (jsonData.type === "Topology") {
        for (key in jsonData.objects) {
          geojson = topojson.feature(jsonData, jsonData.objects[key]);
          L.GeoJSON.prototype.addData.call(this, geojson);
        }
      }
      else {
        L.GeoJSON.prototype.addData.call(this, jsonData);
      }
    }
  }); // Copyright (c) 2013 Ryan Clark

  // CREATE EMPTY TOPOJSON-LEAFLET OBJECTS
  var topoLayer_water    = new L.TopoJSON();
  var topoLayer_admin    = new L.TopoJSON();
  var topoLayer_stations = new L.TopoJSON();

  // CREATE GRADIENTS --> CHECK VARIATIONS FROM COLORBREWER
  var colorScale_water = chroma
    .scale( ['#ffffd9','#edf8b1','#c7e9b4','#7fcdbb','#41b6c4','#1d91c0','#225ea8','#0c2c84'] )
    .domain([0, 0.3]);
  var colorScale_admin = chroma
      .scale( ['#FFEDA0', '#800026'] )
      .domain([0, 0.5]);

  var dft_opacity    = 0.6;
  var dft_weight     = 0.5;
  var dft_null_color = "#f0f0f0";


  function handleLayer(layer, value, layerGroup ){

    if (value != null ){

      fillOpacity = dft_opacity ;

      if (layerGroup == "water") {
        var fillColor = colorScale_water(value).hex();
      } else {
        var fillColor = colorScale_admin(value).hex();
      }
    }

    else {
      var fillColor   = dft_null_color ;
      var fillOpacity = 0 ;
    }

    layer.setStyle({
      fillColor  : fillColor,
      fillOpacity: fillOpacity,
      color      :'white',
      weight     :dft_weight,
      opacity    : 1
    });

    layer.on({
      mouseover: enterLayer,
      mouseout : leaveLayer,
      click    : zoomToFeature
    });
  }

  function enterLayer(){

    this.bringToFront();
    this.setStyle({
      weight : dft_weight + 2,
      opacity: 1
    });
  }

  function leaveLayer(){
    //this.bringToBack();
    this.setStyle({
      weight : dft_weight,
      opacity: dft_opacity
    });
  }

  function zoomToFeature(e) {
      map.fitBounds(e.target.getBounds());
  }



  // var queue = d3_queue.queue(1);
  // queue
  //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.water ) }}" ) // topojson water
  //   .defer(d3.json, "{{ url_for ( 'static', filename = basemaps.admin ) }}" ) // topojson admin
  //   .awaitAll(InitMap_) ;



  //// InitMap as callback function --> first to run then (callback)

  function InitMap (callback) {
  //function InitMap () {
  //InitMap = function (callback) {

    //var def = new $.Deferred();

    // GET TOPOJSON FILES
    $.getJSON( "{{ url_for ( 'static', filename = basemaps.water ) }}" )
      .done(addTopoData_water);
    // $.getJSON( "{{ url_for( 'static', filename = basemaps.admin ) }}" )
    //   .done(addTopoData_admin);

    // PROCESS TOPOJSON // WARNING : OVERWRITES previous TOPOLAYER object
    function addTopoData_water(topoData){
      console.log(" - leaflet -- starting / addTopoData_water ");
      topoLayer_water.addData(topoData);
      topoLayer_water.addTo(water_layer);
      //topoLayer_water.eachLayer(handleWaterLayer); //////////////////
      console.log(" - leaflet -- finished / addTopoData_water ");
    };
    function addTopoData_admin(topoData){
      console.log(" - leaflet -- starting / addTopoData_admin ");
      topoLayer_admin.addData(topoData);
      topoLayer_admin.addTo(admin_layer);
      //topoLayer_admin.eachLayer(handleAdminLayer); /////////////////
      console.log(" - leaflet -- finished / addTopoData_admin ");
    };

    callback();
    //return def.promise();

  }; // <-- end : InitMap


  //
  //ConnectSocketIO = function () {
  function ConnectSocketIO () {

    var var_client = "client is connected";
    var dft_year   = 2012 ;
    var dft_pest   = "XXXXXX" ;
    var dft_df_src = "df_AV_ME" ;

    // INITIATE SOCKET IO CONNECTION
    var socket = io.connect('http://' + document.domain + ':' + location.port);

    socket.on('connect', function() {

      // socket.emit('connection start', {data: '--> client connected from : ' + document.domain + ':' + location.port });
      socket.emit('io_request_water', {
        msg                 : var_client ,
        df_source           : dft_df_src ,
        slice_query_index   : [ dft_year, dft_pest ] ,
        slice_query_columns : [ ]
      });
    });

    socket.on('io_slice_from_server', function(data_slice) {

      var req        = data_slice.request_sent ;
      var data_water = data_slice.data_water ;

      console.log(" io_slice_from_server / request :",req) ;

      var data_slice = JSON.parse(data_water) ;

        // update layer data
        topoLayer_water.eachLayer( function(layer) {

          var index_ME = layer.feature.properties.CdMasseDEa ;
          console.log(" io_slice_from_server / index_ME : ", index_ME)

          var data_ME = data_slice[index_ME] ;
          console.log(" io_slice_from_server / index_ME : " + index_ME + " / data_ME : ", data_ME) ;

          layer.feature.properties.value = data_ME ;

          if (data_ME != null ){
            if (data_ME["2012_XXXXXX"] != null ) {
              value = data_ME["2012_XXXXXX"]
            }
          } else {
            value = null
          }
          handleLayer(layer, value , "water");

        });

    }); // <-- end : io_slice_from_server

  }; // <-- end : ConnectSocketIO


  //$(document).ready(function() { // <-- place at top to run stuff in order

    //InitMap().then(ConnectSocketIO); // <-- with defer
    InitMap( ConnectSocketIO ); // <-- with callback
    //ConnectSocketIO();

  //}); //<-- end : $(document).ready


</script>
